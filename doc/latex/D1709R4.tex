\documentclass[10pt,onecolumn]{article}

\usepackage[
	left=0.75in,
	top=0.75in,
	right=0.75in,
	bottom=0.75in]{geometry}
\usepackage{soul}
\usepackage{times}
\usepackage[scaled=.90]{helvet} % Use helvetica for sf and scale to proper size
\usepackage{amssymb} % for checkmark

%% \usepackage{url}  %% use hyperref instead

%% Define colors
\usepackage[hyperref]{xcolor}

\definecolor{light-gray}{gray}{0.95}
\definecolor{medium-gray}{gray}{0.33}

\definecolor{bs_keyword}{HTML}{990055} % {D33682} 
\definecolor{bs_name_function}{HTML}{0077AA} % {268BD2}
\definecolor{bs_comment_single}{HTML}{708090} % {2AA198}
\definecolor{bs_name}{HTML}{0077AA} % {2AA198}
\definecolor{bs_number}{HTML}{000000}
\definecolor{bs_string}{HTML}{A67F59}
\definecolor{bs_highlight_background}{HTML}{F2F2F2}
\definecolor{bs_h1_h2_h3}{HTML}{005A9C}
\definecolor{bs_a_href}{HTML}{034575}
\definecolor{comment}{HTML}{0000A0}

%% Customize section headings
\usepackage{titlesec}
\titleformat*{\section}{\normalfont\Large\bfseries\color{bs_h1_h2_h3}}
\titleformat*{\subsection}{\normalfont\large\bfseries\color{bs_h1_h2_h3}}
\titleformat*{\subsubsection}{\normalfont\normalsize\bfseries\color{bs_h1_h2_h3}}

%% Customize hyperlinks
\usepackage{hyperref}
\hypersetup{
  colorlinks = true,
  linkcolor = bs_h1_h2_h3% {0 .35 .61} % 005A9C
}

%% Customize code formatting
%% Note that P2300 uses Menlo, Consolas, "DejaVu Sans Mono", Monaco, monospace;
%% TODO (maybe)
%% To use with XeLaTeX:
%% \usepackage{fontspec}
%% \newfontfamily{\lstsansserif}[Scale=.85]{Menlo}
%% \lstset{basicstyle=\lstsansserif}
%% To handle numbers:
%% cf. https://tex.stackexchange.com/questions/34896/coloring-digits-with-the-listings-package
\usepackage{listings}
\lstset
{
  language=[11]C++,
  backgroundcolor=\color{bs_highlight_background},
  basicstyle=\ttfamily, % \bf\ttfamily,
  breaklines=true,
  commentstyle=\color{bs_comment_single},
  keywordstyle=\color{bs_keyword},
  identifierstyle=\color{bs_name_function},
  stringstyle=\color{bs_string},
  frame=single,
  framerule=0pt,
  showstringspaces=false
}

%% Keywords for C++20
\lstset{
  morekeywords = {
    char8_t,
    concept,
    consteval,
    co_await,
    co_return,
    co_yield,
    requires,
    import,
    module
  }
}

%% \lstset{
%%   emph = { % [20]
%%     import,
%%     module
%%   }
%% }

\usepackage{array}
\newcolumntype{L}[1]{>{\raggedright\arraybackslash}p{#1}}
\newcolumntype{R}[1]{>{\raggedleft\arraybackslash}p{#1}}

\usepackage{arydshln}
\usepackage{graphicx}

%% Shortcut for inline code
\newcommand{\tcode}[1]{\lstinline[breaklines=true]{#1}}

\newcommand{\comment}[2]{{\color{comment}[{\sc #1:} \textsf{#2}]}}
\newcommand{\phil}[1]{\comment{Phil}{#1}}
\newcommand{\andrew}[1]{\comment{Andrew}{#1}}



\begin{document}

\begin{titlepage}
~
\vfill
\begin{center}
\LARGE
\textbf{\hl{D1709R4} Graph Library}\\
\vspace{12pt}
\normalsize
	Phillip Ratzloff (SAS Institute)\\
	Andrew Lumsdaine (TileDB/University of Washington)\\
\end{center}
\vspace{32pt}
\begin{tabular}{ll}
\textbf{Document Number:} & \hl{D1709R4} \\
\textbf{Date:} & \hl{December, 2022 (goal)} (mailing)\\ 
\textbf{Project:} & ISO JTC1/SC22/WG21: Programming Language C++\\
\textbf{Audience:} & SG19, WG21, LEWG\\
\textbf{Source:} & \href{https://github.com/stdgraph/graph-v2}{Github} \\
\textbf{Issue Tracking:} & \href{https://github.com/stdgraph/graph-v2/issues}{Github} \\
\textbf{Contributors:}
	&Richard Dosselmann (University of Regina)\\
	&Michael Wong (Codeplay)\\
	&Matthew Galati (Amazon)\\	
	&Jens Maurer\\
	&Domagoj Saric\\
	&Jesun Firoz\\
	&Kevin Deweese\\
\textbf{Emails:}
	&\texttt{Phil.Ratzloff@sas.com}\\
	&\texttt{Andrew.Lumsdaine@tiledb.com}\\
	&\texttt{dosselmr@cs.uregina.ca}\\
	&\texttt{michael@codeplay.com}\\
	&\texttt{magalati@amazon.com}\\
\textbf{Reply to:}
	&\texttt{\textbf{Phil.Ratzloff@sas.com}}\\
\end{tabular}
\vfill
~
\end{titlepage}

\tableofcontents

\clearpage

\section*{Revision History}
\subsection*{P1709R4}
This was a major redesign that incorporated all the experience and input from the past 3 years.
\begin{itemize}
\item Reduce the scope to focus on an edge list and adjacency graph with outgoing edges only, and remove mutable interface functions. 
\item Replace directed and undirected concepts with overridable types of unordered\_edge for a graph implementation type.
\item Simplify the Graph Container types and functions. In particular, const and non-const variations were consolidated to a single definition to handle both cases 
when appropriate.
\item All Graph Container Interface functions are customization points.
\item Introduce Views, inspired by NWGraph design, resulting in simpler and cleaner interfaces to traverse a graph, and simplifying the container interface design.
\item Revisit the algorithms to be considered. transitive\_closure has been dropped. The final list hasn't been finalized yet.
\item Replace the two container implementations with csr\_graph.
\end{itemize}

\subsection*{P1709R3}
A simple status revision to say a major change is coming soon.

\subsection*{P1709R2}
Define the \textbf{uniform API} for undirected and directed algorithms (an extended API also exists for directed graphs). Added \textbf{concepts} for undirected, directed and bidirected graphs. Refined \textbf{DFS} and \textbf{BFS} range definitions from prototype experience. Refined \textbf{shortest paths} and \textbf{transitive closure} algorithms from input and prototype experience.

\subsection*{P1709R1}
Rewrite with a focus on a \textbf{purely functional design}, emphasizing the algorithms and graph API. Also added \textbf{concepts} and \textbf{ranges} into the design. Addressed concerns from Cologne review to change to functional design.

\subsection*{P1709R0}
Focus on \textbf{object-oriented API} for data structures and example code for a few algorithms.

\section{Introduction}
This document proposes the addition of \textbf{graph algorithms}, \textbf{graph views}, \textbf{graph container interface} and a \textbf{graph container implementation} to the C++ library to support \textbf{machine learning} (ML), as well as other applications. ML is a large and growing field, both in the \textbf{research community} and \textbf{industry}, that has received a great deal of attention in recent years. This paper presents an \textbf{interface} of the proposed algorithms, views, graph functions and containers.

\subsection{Motivation}
Graphs, used in ML and other \textbf{scientific} domains, as well as \textbf{industrial} and \textbf{general} programming, do \textbf{not} presently exist in the C++ standard. In ML, a graph forms the underlying structure of an \textbf{artificial neural network} (ANN). In a \textbf{game}, a graph can be used to
represent the \textbf{map} of a game world. In \textbf{business} environments, graphs arise as \textbf{entity relationship diagrams} (ERD) or \textbf{data flow diagrams} (DFD). In the realm of \textbf{social media}, a graph represents a \textbf{social network}.

\subsection{Goals and Priorities}
\begin{itemize}
\item Follow the separation of algorithms, ranges, views and containers established by the standard library.
\item All free functions should be customization point objects, unless there's a good reason not to. Reasonable default implementations should be provided whenever possible.
\item Graph algorithms have the following characteristics
\begin{itemize}
\item Support syntax that is simple, expressive and easy to understand. This should not compromise the ability to write high-performance algorithms.
\item Vertices are required to be in random access containers with an integral vertex\_id in this proposal.
\end{itemize}
\item Graph views provide common traversals of a graph's vertices and edges that is more concise and consistant than using the graph container interface directly. They include simple traversals like vertexlist (all vertices in the graph) and incidence edges (edges on a vertex), as well as more complex traversals like depth-first and breath-first searches.
\item The Graph Container Interface provides a consistent interface that can be used by algorithms and views. It has the following characteristics:
\begin{itemize}
\item The interface models an adjacency graph container, which is an outer range of vertices with an inner range of outgoing (a.k.a. incidence) edges on each vertex. 
\item Definition of concepts, types, type traits, type aliases, and functions used by algorithms and views.
\begin{itemize}
\item Type traits will be defined that can be overridden for each graph container to give additional hints that can be used by algorithms to refine their behavior, such as adjacency\_matrix and unordered\_edge.
\end{itemize}
\item Support of optional user-defined value types on an edge, vertex and/or the graph itself.
\item Allow for useful extensions of the graph data model in future proposals or in external graph implementations. 
\end{itemize}
\item Provide an initial suite of useful functionality that includes algorithms, views, container interface, and at least one container implementation.
\end{itemize}

\subsection{What this proposal is  \textbf{not}}
This paper limits itself to adjacency graphs only, including an outer range of vertices with an inner range of outgoing edges on each vertex. It also includes an edgelist of all edges in the graph, either as a edgelist view or a simple range with a source\_id and target\_id. It does not include incoming edges on a vertex, though that could be a future extension.

\hl{Bipartite graphs} are being investigated. A general design has been established and it needs to be implemented to validate that it will work and see what areas of the design are impacted.

Parallel versions of the algorithms are not included for several reasons. The executors proposal in P2300r5 \cite{REF_P2300r5} is expected to introduce new and better ways to do parallel algorithms beyond that used in the parallel STL algorithms and we would like to wait for finalization of that proposal before committing to parallel implementations. Secondly, many graph algorithms don't benefit from parallel implementations so there is less need to offer an implementation. Lastly, it will help limit the size of this proposal which is already looking to be large without it. It is expected that future proposals will be submitted for parallel graph algorithms. 

Hypergraphs are not supported.

\subsection{Impact on the Standard}
This proposal is a pure \textbf{library} extension.

\subsection{Interaction wtih Other Papers}
There is no interaction with other proposals to the standard.

\subsection{Implementation experience}
The github \href{https://github.com/stdgraph}{stdgraph} repository contains an implementation for this proposal.

\subsection{Usage experience}
\subsection{Deployment experience}
\subsection{Performance considerations}
The algorithms are being ported from NWGraph to the \href{https://github.com/stdgraph}{stdgraph} implementation used for this proposal. Performance analysis from those algorithms can be found in the peer-reviewed paper for NWGraph \cite{REF_nwgraph_paper}.

\subsection{Prior Art}
\textbf{boost::graph} has been an important C++ graph implementation since 2001. It was developed with the goal to provide
a modern library that addressed all the needs someone would want of a graph library. It is still a viable library used today,
attesting to the value it brings.

However, boost::graph was written using C++98 and added many unneccesary abstractions that makes it difficult
to use by a casual developer. 

Andrew is a co-author of boost::graph.
\\

\textbf{NWGraph} (\cite{REF_nwgraph_library} and \cite{REF_nwgraph_paper}) was published in 2022
by Andrew et al, bringing additional experience gained since creating boost::graph, to create a modern graph library that
was more accessible to the average developer using C++20 to create a simpler interface with the latest algorithms.

While NWGraph made
important strides, there are some areas that don't conform to established expectations in the Standard Library. Examples
include using parameter packs to define multiple value types for an edge, rather than a single type; a focus on only defing value types on edges, but not vertices or the graph. it has no defined way to
integrate existing graph containers to be used by the algorithms.
\\

This proposal takes the best of NWGraph, with work by Phil to define a Graph Container Interface, to provide a library that
embraces performance, ease-of-use and the ability to use the algorithms and views on externally defined graph containers.

\subsection{Alternatives}
There are no known alternative graph library we're aware of that meets the same requirements and uses concepts and ranges from C++20.

%Later revisions should include this:
%\subsection{Changes Library Evolution previously requested}

\subsection{Feature test macro}
The \tcode{__cpp_lib_graph} feature test macro is recommended to represent all features in this proposal including algorithms, views, concepts, traits, types, functions and graph container(s).

Future features could extend the name for new features. For instance, \tcode{__cpp_lib_graph_partite_container} could be used if an n-partite graph container were added in later C++ versions.

\subsection{Freestanding}
We believe this library can be used in a freestanding C++ implementation.

\subsection{Namespaces}
Graph containers and their views and algorithms are not interchangeable with existing containers and algorithms.
It is believed that they are unique enough to warrant their own namespaces and is used in this proposal.
\begin{itemize}
\item[]\tcode{std::graph}
\item[]\tcode{std::graph::views}
\end{itemize}

\noindent
Alternative locations for the above respective namespaces could also be as follows:
\begin{itemize}
\item[]\tcode{std}, or \tcode{std::ranges}
\item[]\tcode{std::ranges::views}
\end{itemize}


% algorithms: 
% views: 
% containers: adjacency matrix
% data model: incoming edges on a vertex

\section{Design - Introduction}

Table \ref{tab:name_conv} shows the naming conventions used throughout this document. 

\begin{table}[h!]
\begin{center}
{\begin{tabular}{l l l p{7cm}}
\hline
    \textbf{Template} & & \textbf{Variable} & \\
    \textbf{Parameter} & \textbf{Type Alias} & \textbf{Names} & \textbf{Description} \\
\hline
    \tcode{G} & & & Graph \\
    & \tcode{graph_reference_t<G>} & \tcode{g} & Graph reference \\
    \tcode{GV} &  & \tcode{val} & Graph Value, value or reference \\
\hline
    \tcode{V} & \tcode{vertex_t<G>} & & Vertex \\
    & \tcode{vertex_reference_t<G>} & \tcode{u,v,x,y} & Vertex reference. \tcode{u} is the source (or only) vertex. \tcode{v} is the target vertex. \\
    \tcode{VId} & \tcode{vertex_id_t<G>} & \tcode{uid,vid,seed} & Vertex id. \tcode{uid} is the source (or only) vertex id. \tcode{vid} is the target vertex id. \\
    \tcode{VV} &  \tcode{vertex_value_t<G>} & \tcode{val} & Vertex Value, value or reference. This can be either the user-defined value on a vertex, or a value returned by a function object (e.g. \tcode{VVF}) that is related to the vertex. \\
    \tcode{VR} &  \tcode{vertex_range_t<G>} & \tcode{ur,vr} & Vertex Range \\
    \tcode{VI} & \tcode{vertex_iterator_t<G>} & \tcode{ui,vi} & Vertex Iterator. \tcode{ui} is the source (or only) vertex. \\
                    &  & \tcode{first,last} & \tcode{vi} is the target vertex. \\
    \tcode{VVF} & & \tcode{vvf} & Vertex Value Function: vvf(u) $\rightarrow$ value \\
\hline
    \tcode{E} & \tcode{edge_t<G>} & & Edge \\
    & \tcode{edge_reference_t<G>} & \tcode{uv,vw} & Edge reference. \tcode{uv} is an edge from vertices \tcode{u} to \tcode{v}. \tcode{vw} is an edge from vertices \tcode{v} to \tcode{w}.  \\
    \tcode{EV} &  \tcode{edge_value_t<G>} & \tcode{val} & Edge Value, value or reference. This can be either the user-defined value on an edge, or a value returned by a function object (e.g. \tcode{EVF}) that is related to the edge. \\
    \tcode{ER} &  \tcode{vertex_edge_range_t<G>} & & Edge Range for edges of a vertex \\
    \tcode{EI} & \tcode{vertex_edge_iterator_t<G>} & \tcode{uvi,vwi} & Edge Iterator for an edge of a vertex. \tcode{uvi} is an iterator for an edge from vertices \tcode{u} to \tcode{v}. \tcode{vwi} is an iterator for an edge from vertices \tcode{v} to \tcode{w}. \\
    \tcode{EVF} & & \tcode{evf} & Edge Value Function: evf(uv) $\rightarrow$ value \\
\hline
\end{tabular}}
\caption{Naming Conventions for Types and Variables}
\label{tab:name_conv}
\end{center}
\end{table}

\subsection{Graph Data Models}
\subsubsection{Adjacency Graph}
 A \textit{graph} \cite{REF_graph} $G = (V, E)$ is a set of \textit{vertices} \cite{REF_graph} $V$, \textbf{points} in a space, and \textit{edges} \cite{REF_graph} $E$, \textbf{links} between these vertices. Edges may or may not be \textbf{oriented}, that is, \textit{directed} \cite{REF_graph} or \textit{undirected} \cite{REF_graph}, respectively. Moreover, edges may be \textit{weighted} \cite{REF_graph}, that is, assigned a value. Both \textbf{static} and \textbf{dynamic} implementations of a graph exist, specifically a (static) \textbf{matrix}, each having the typical advantages and disadvantages associated with static and dynamic data structures.

%% adjacency graph, vertex, edge
%% incidence, neighbors (adjacency)
%% optional user-defined values for edge, vertex, graph

\subsubsection{Edge List}
% range with source_id & target_id members, and optional value member(s)
% edgelist view

\subsection{Examples}
\subsubsection{Example: User}
\subsubsection{Example: Graph Author}

\section{Design - User Side}
\subsection{Algorithms}
%Algorithms with [TBD] are candidates to consider but having been decided for being in the paper
%We are targeting the paper to be under 50pp
\phil{Algorithms marked [TBD] are provisional and may be moved to a separate proposal to keep the size of this proposal manageable}

\subsubsection{Dijkstra's Shortest Paths}
Dijkstra's algorithm \cite{REF_} ...

\subsubsection{Bellman-Ford Shortest Paths}
The Bellman-Ford algorithm \cite{REF_} ...

\subsubsection{Connected Components}
Connected components \cite{REF_} ...

\subsubsection{Strongly Connected Components}
Strongly connected components \cite{REF_} ...

\subsubsection{Biconnected Components}
Biconnected components \cite{REF_} ...

\subsubsection{Articulation Points}
Articulation points \cite{REF_} ...

\subsubsection{Minimum Spanning Tree}
Minimum Spanning Tree \cite{REF_} ...

\subsubsection{[TBD] Page Rank}
\subsubsection{[TBD] Betweenness Centrality}
\subsubsection{[TBD] Triangle Count}
\subsubsection{[TBD] Subgraph Isomorphism}
\subsubsection{[TBD] Kruskell Minimum Spanning Tree}
\subsubsection{[TBD] Prim Minimum Spanning Tree}
\subsubsection{[TBD] Louvain (Community Detection)}
\subsubsection{[TBD] Label propagation (Community Detection)}

\subsection{Views}
The views in this section provide comman ways that algorithms use to traverse graphs. They are a simple as iterating through the set of vertices, or more complex ways such as depth-first search and breadth-first search. The also provide a consistent and reliable way to access related elements using the View Return Types, and guaranteeing expected values, such as that the target is really the target on unordered edges.

\subsubsection{Return Types}
Views return one of the types in this section, providing a consistent set of values. They are templated so that the view can adjust the actual values returned to be appropriate for its use. The following examples show the general design and how it's used. While it focuses on vertexlist to iterate over all vertices, it applies to all view functions.

\begin{lstlisting}
// the type of uu is vertex_view<vertex_id_t<G>, vertex_reference_t<G>, void>
for(auto&& uu : vertexlist(g)) {
  vertex_id<G>          id = uu.id;
  vertex_reference_t<G> u  = uu.vertex;
  // ... do something interesting
}
\end{lstlisting}

Structured bindings make it simpler.
\begin{lstlisting}
for(auto&& [id, u] : vertexlist(g)) {
  // ... do something interesting
}
\end{lstlisting}

A function object can also be passed to return a value from the vertex. In this case, \tcode{vertexlist(g)} returns \tcode{vertex_view<vertex_id_t<G>, vertex_reference_t<G>, decltype(vvf(u))>}.
\begin{lstlisting}
// the type returned by vertexlist is 
// vertex_view<vertex_id_t<G>, 
//             vertex_reference_t<G>, 
//             decltype(vvf(vertex_reference_t<G>))>
auto vvf = [&g](vertex_reference_t<G> u) { return vertex_value(g,u); };
for(auto&& [id, u, value] : vertexlist(g, vvf)) {
  // ... do something interesting
}
\end{lstlisting}

\paragraph{\tcode{struct vertex_view<Vid, V, VV>}}\label{vertex-view}\mbox{} \\
\tcode{vertex_view} is used to return vertex information. It is used by \tcode{vertexlist(g)}, \tcode{vertices_breadth_first_search(g,u)}, \tcode{vertices_depth_first_search(g,u)} and others. The \tcode{id} member always exists.

\begin{lstlisting}
template <class VId, class V, class VV>
struct vertex_view {
  VId id;     // vertex_id_t<G>, always exists
  V   vertex; // vertex_reference_t<t>
  VV  value;
};
\end{lstlisting}

Specializations are defined with \tcode{V}=void or \tcode{VV}=void to suppress the existance of their associated member variables, giving the following valid combinations in Table \ref{tab:vertex-view} . For instance, the second entry, \tcode{vertex_view<VId, V>} has two members \tcode{\{VId id; V vertex;\}}.
\begin{table}[h!]
\begin{center}
%\resizebox{\textwidth}{!}
{\begin{tabular}{l |c c c}
\hline
    \multicolumn{1}{l}{\textbf{Template Arguments}}
    &
    \multicolumn{3}{c}{\textbf{Members}} \\
    %\textbf{Template Arguments} & id & vertex & value \\
\hline
    \tcode{vertex_view<VId, V, VV>} & \tcode{id} & \tcode{vertex} & \tcode{value} \\
    \tcode{vertex_view<VId, V, void>} & \tcode{id} & \tcode{vertex} & \\
    \tcode{vertex_view<VId, void, VV>} & \tcode{id} & & \tcode{value} \\
    \tcode{vertex_view<VId, void, void>} & \tcode{id} & & \\
\hline
\end{tabular}}
\caption{\tcode{vertex_view} Members}
\label{tab:vertex-view}
\end{center}
\end{table}

A useful type alias for copying vertex values (excluding the vertex reference) is also available.
\begin{lstlisting}
template <class VId, class VV>
using copyable_vertex_t = vertex_view<VId, void, VV>; // {id, value}
\end{lstlisting}

\paragraph{\tcode{struct edge_view<VId, Sourced, E, EV>}}\label{edge-view}\mbox{} \\
\tcode{edge_view} is used to return edge information. It is used by \tcode{incidence(g,u)}, \tcode{edgelist(g)}, \tcode{edges_breadth_first_search(g,u)}, \tcode{edges_depth_first_search(g,u)} and others. When \tcode{Sourced}=true, the \tcode{source_id} member is included with type \tcode{VId}. The \tcode{target_id} member always exists.

\begin{lstlisting}
template <class VId, bool Sourced, class E, class EV>
struct edge_view {
  VId source_id; // vertex_id_t<G>, exists when SourceId==true
  VId target_id; // vertex_id_t<G>, always exists
  E   edge;      // edge_reference_t<G>
  EV  value;
};
\end{lstlisting}

Specializations are defined with \tcode{Sourced}=true\(|\)false, \tcode{E}=void or \tcode{EV}=void to suppress the existance of the associated member variables, giving the following valid combinations in Table \ref{tab:edge-view} . For instance, the second entry, \tcode{edge_view<VId,true,E>} has three members \tcode{\{VId source_id; VId target_id; E edge;\}}.
\begin{table}[h!]
\begin{center}
%\resizebox{\textwidth}{!}
{\begin{tabular}{l |c c c c}
\hline
    \multicolumn{1}{l}{\textbf{Template Arguments}}
    &
    \multicolumn{4}{c}{\textbf{Members}} \\
    %\textbf{Template Arguments} & id & edge & value \\
\hline
    \tcode{edge_view<VId, true, E, EV>} & \tcode{source_id} & \tcode{target_id} & \tcode{edge} & \tcode{value} \\
    \tcode{edge_view<VId, true, E, void>} & \tcode{source_id} & \tcode{target_id} & \tcode{edge} & \\
    \tcode{edge_view<VId, true, void, EV>} & \tcode{source_id} & \tcode{target_id} & & \tcode{value} \\
    \tcode{edge_view<VId, true, void, void>} & \tcode{source_id} & \tcode{target_id} & & \\
    \tcode{edge_view<VId, false, E, EV>} & & \tcode{target_id} & \tcode{edge} & \tcode{value} \\
    \tcode{edge_view<VId, false, E, void>} & & \tcode{target_id} & \tcode{edge} & \\
    \tcode{edge_view<VId, false, void, EV>} & & \tcode{target_id} & & \tcode{value} \\
    \tcode{edge_view<VId, false, void, void>} & & \tcode{target_id} & & \\
\hline
\end{tabular}}
\caption{\tcode{edge_view} Members}
\label{tab:edge-view}
\end{center}
\end{table}

A useful type alias for copying edge values (excluding the edge reference) is also available.
\begin{lstlisting}
template <class VId, class EV>
using copyable_edge_t = edge_view<VId, true, void, EV>; // {source_id, target_id [, value]}
\end{lstlisting}


\paragraph{\tcode{struct neighbor_view<VId, Sourced, V, VV>}}\label{neighbor-view}\mbox{} \\
\tcode{neighbor_view} is used to return information for a neighbor vertex, through an edge. It is used by \tcode{neighbors(g,u)}. When \tcode{Sourced}=true, the \tcode{source_id} member is included with type \tcode{VId}. The \tcode{target_id} member always exists.

\begin{lstlisting}
template <class VId, bool Sourced, class V, class VV>
struct neighbor_view {
  VId source_id;  // vertex_id_t<G>
  VId target_id;  // vertex_id_t<G>, always exists
  V   target;     // vertex_reference_t<G>
  VV  value;
};
\end{lstlisting}

Specializations are defined with \tcode{Sourced}=true\(|\)false, \tcode{E}=void or \tcode{EV}=void to suppress the existance of the associated member variables, giving the following valid combinations in Table \ref{tab:neighbor-view} . For instance, the second entry, \tcode{neighbor_view<VId,true,E>} has three members \tcode{\{VId source_id; VId target_id; V target;\}}.
\begin{table}[h!]
\begin{center}
%\resizebox{\textwidth}{!}
{\begin{tabular}{l |c c c c}
\hline
    \multicolumn{1}{l}{\textbf{Template Arguments}}
    &
    \multicolumn{4}{c}{\textbf{Members}} \\
\hline
    \tcode{neighbor_view<VId, true, E, EV>} & \tcode{source_id} & \tcode{target_id} & \tcode{target} & \tcode{value} \\
    \tcode{neighbor_view<VId, true, E, void>} & \tcode{source_id} & \tcode{target_id} & \tcode{target} & \\
    \tcode{neighbor_view<VId, true, void, EV>} & \tcode{source_id} & \tcode{target_id} & & \tcode{value} \\
    \tcode{neighbor_view<VId, true, void, void>} & \tcode{source_id} & \tcode{target_id} & & \\
    \tcode{neighbor_view<VId, false, E, EV>} & & \tcode{target_id} & \tcode{target} & \tcode{value} \\
    \tcode{neighbor_view<VId, false, E, void>} & & \tcode{target_id} & \tcode{target} & \\
    \tcode{neighbor_view<VId, false, void, EV>} & & \tcode{target_id} & & \tcode{value} \\
    \tcode{neighbor_view<VId, false, void, void>} & & \tcode{target_id} & & \\
\hline
\end{tabular}}
\caption{\tcode{neighbor_view} Members}
\label{tab:neighbor-view}
\end{center}
\end{table}

\subsubsection{Common Types and Functions for ``Search'' }
The depth\_first\_search, breadth\_first\_search, and toplogical\_sort searches there are a number of common types and functions that apply to them. 

Here are the types and functions for cancelling a search, getting the current depth of the search, and active elements in the search (e.g. number of vertices in a stack or queue).
\begin{lstlisting}
// enum used to define how to cancel a search
enum struct cancel_search : int8_t { 
  continue_search, // no change (ignored)
  cancel_branch,   // stops searching from current vertex
  cancel_all       // stops searching and dfs will be at end()
};

// stop searching from current vertex
template<class S)
void cancel(S search, cancel_search);

// Returns distance from the seed vertex to the current vertex, 
// or to the target vertex for edge views
template<class S>
auto depth(S search) -> integral;

// Returns number of pending vertices to process
template<class S>
auto size(S search) -> integral; 
\end{lstlisting}

Of particular note, \tcode{size(dfs)} is typically the same as \tcode{depth(dfs)} and is simple to calculate. breadth\_first\_search requires extra bookkeeping to evaluate \tcode{depth(bfs)} and returns a different value than \tcode{size(bfs)}.

The following example shows how the functions  could be used, using \tcode{dfs} for one of the depth\_first\_search views. The same functions can be used for all all search views.
\begin{lstlisting}
auto&& g = ...; // graph
auto&& dfs = vertices_depth_first_search(g,0); // start with vertex_id=0
for(auto&& [vid,v] : dfs) {
  // No need to search deeper?
  if(depth(dfs) > 3) {
    cancel(dfs,cancel_search::cancel_branch);
    continue;
  }
  
  if(size(dfs) > 1000) {
    std::cout << "Big depth of " << size(dfs) << '\n';
  }
  
  // do useful things
}

\end{lstlisting}

\subsubsection{vertexlist Views}
\
\tcode{vertexlist} views iterate over a range of vertices, returning a \tcode{vertex_view} on each iteration. 
Table \ref{tab:vertexlist} shows the vertexlist functions overloads and their return values. \tcode{first} and \tcode{last} are vertex iterators.

\begin{table}[h!]
\begin{center}
%\resizebox{\textwidth}{!}
{\begin{tabular}{l l}
\hline
    \textbf{Example} & \textbf{Return} \\
\hline
    \tcode{for(auto\&\& [uid,u] : vertexlist(g))} & \tcode{vertex_view<VId,V,void>} \\
    \tcode{for(auto\&\& [uid,u,val] : vertexlist(g,vvf))} & \tcode{vertex_view<VId,V,VV>} \\
    \tcode{for(auto\&\& [uid,u] : vertexlist(g,first,last))} & \tcode{vertex_view<VId,V,void>} \\
    \tcode{for(auto\&\& [uid,u,val] : vertexlist(g,first,last,vvf))} & \tcode{vertex_view<VId,V,VV>} \\
    \tcode{for(auto\&\& [uid,u] : vertexlist(g,vr))} & \tcode{vertex_view<VId,V,void>} \\
    \tcode{for(auto\&\& [uid,u,val] : vertexlist(g,vr,vvf))} & \tcode{vertex_view<VId,V,VV>} \\
\hline
\end{tabular}}
\caption{\tcode{vertexlist} View Functions}
\label{tab:vertexlist}
\end{center}
\end{table}

\subsubsection{incidence Views}
\tcode{incidence} views iterate over a range of adjacent edges of a vertex, returning a \tcode{edge_view} on each iteration. 
Table \ref{tab:incidence} shows the \tcode{incidence} function overloads and their return values. 

Since the source vertex \tcode{u} is available when calling an \tcode{incidence} function, there's no need to include sourced versions of the function to include \tcode{source_id} in the output.

\begin{table}[h!]
\begin{center}
%\resizebox{\textwidth}{!}
{\begin{tabular}{l l}
\hline
    \textbf{Example} & \textbf{Return} \\
\hline
    \tcode{for(auto\&\& [vid,uv] : incidence(g,u))} & \tcode{edge_view<VId,false,E,void>} \\
    \tcode{for(auto\&\& [vid,uv,val] : incidence(g,u,evf))} & \tcode{edge_view<VId,false,E,EV>} \\
\hline
\end{tabular}}
\caption{\tcode{incidence} View Functions}
\label{tab:incidence}
\end{center}
\end{table}

\subsubsection{neighbors Views}
\tcode{neighbors} views iterate over a range of edges for a vertex, returning a \tcode{vertex_view} of each neighboring target vertex on each iteration. 
Table \ref{tab:neighbors} shows the \tcode{neighbors} function overloads and their return values. 

Since the source vertex \tcode{u} is available when calling a \tcode{neighbors} function, there's no need to include sourced versions of the function to include \tcode{source_id} in the output.

\begin{table}[h!]
\begin{center}
%\resizebox{\textwidth}{!}
{\begin{tabular}{l l}
\hline
    \textbf{Example} & \textbf{Return} \\
\hline
    \tcode{for(auto\&\& [vid,v] : neighbors(g,u))} & \tcode{neighbor_view<VId,false,V,void>} \\
    \tcode{for(auto\&\& [vid,v,val] : neighbors(g,u,vvf))} & \tcode{neighbor_view<VId,false,V,VV>} \\
\hline
\end{tabular}}
\caption{\tcode{neighbors} View Functions}
\label{tab:neighbors}
\end{center}
\end{table}

\subsubsection{edgelist Views}
\tcode{edgelist} views iterate over all edges for all vertices, returning a \tcode{edge_view} on each iteration. 
Table \ref{tab:edgelist} shows the \tcode{edgelist} function overloads and their return values. 

\begin{table}[h!]
\begin{center}
%\resizebox{\textwidth}{!}
{\begin{tabular}{l l}
\hline
    \textbf{Example} & \textbf{Return} \\
\hline
    \tcode{for(auto\&\& [uid,vid,uv] : edgelist(g))} & \tcode{edge_view<VId,true,E,void>} \\
    \tcode{for(auto\&\& [uid,vid,uv,val] : edgelist(g,evf))} & \tcode{edge_view<VId,true,E,EV>} \\
\hline
\end{tabular}}
\caption{\tcode{edgelist} View Functions}
\label{tab:edgelist}
\end{center}
\end{table}

\subsubsection{depth\_first\_search Views}
depth\_first\_search views iterate over the vertices and edges from a given seed vertex, returning a \tcode{vertex_view} or \tcode{edge_view} on each iteration when it is first encountered, depending on the function used. 
Table \ref{tab:dfs} shows the functions and their return values.

While not shown in the examples, all functions have a final, optional allocator parameter that defaults to \tcode{std::allocator<bool>}. It is used for containers that are internal to the view. The \tcode{<bool>} argument has no particular meaning.

\begin{table}[h!]
\begin{center}
\resizebox{\textwidth}{!}
{\begin{tabular}{l l}
\hline
    \textbf{Example} & \textbf{Return} \\
\hline
    \tcode{for(auto\&\& [vid,v] : vertices_depth_first_search(g,seed))} & \tcode{vertex_view<VId,V,void>} \\
    \tcode{for(auto\&\& [vid,v,val] : vertices_depth_first_search(g,seed,vvf))} & \tcode{vertex_view<VId,V,VV>} \\
\hline
    \tcode{for(auto\&\& [vid,uv] : edges_depth_first_search(g,seed))} & \tcode{edge_view<VId,false,E,void>} \\
    \tcode{for(auto\&\& [vid,uv,val] : edges_depth_first_search(g,seed,evf))} & \tcode{edge_view<VId,false,E,EV>} \\
\hline
    \tcode{for(auto\&\& [uid,vid,uv] : sourced_edges_depth_first_search(g,seed))} & \tcode{edge_view<VId,true,E,void>} \\
    \tcode{for(auto\&\& [uid,vid,uv,val] : sourced_edges_depth_first_search(g,seed,evf))} & \tcode{edge_view<VId,true,E,EV>} \\
\hline
\end{tabular}}
\caption{depth\_first\_search View Functions}
\label{tab:dfs}
\end{center}
\end{table}

\subsubsection{breadth\_first\_search Views}
breadth\_first\_search views iterate over the vertices and edges from a given seed vertex, returning a \tcode{vertex_view} or \tcode{edge_view} on each iteration when it is first encountered, depending on the function used. 
Table \ref{tab:bfs} shows the functions and their return values.

While not shown in the examples, all functions have a final, optional allocator parameter that defaults to \tcode{std::allocator<bool>}. It is used for containers that are internal to the view. The \tcode{<bool>} argument has no particular meaning.

\begin{table}[h!]
\begin{center}
\resizebox{\textwidth}{!}
{\begin{tabular}{l l}
\hline
    \textbf{Example} & \textbf{Return} \\
\hline
    \tcode{for(auto\&\& [vid,v] : vertices_breadth_first_search(g,seed))} & \tcode{vertex_view<VId,V,void>} \\
    \tcode{for(auto\&\& [vid,v,val] : vertices_breadth_first_search(g,seed,vvf))} & \tcode{vertex_view<VId,V,VV>} \\
\hline
    \tcode{for(auto\&\& [vid,uv] : edges_breadth_first_search(g,seed))} & \tcode{edge_view<VId,false,E,void>} \\
    \tcode{for(auto\&\& [vid,uv,val] : edges_breadth_first_search(g,seed,evf))} & \tcode{edge_view<VId,false,E,EV>} \\
\hline
    \tcode{for(auto\&\& [uid,vid,uv] : sourced_edges_breadth_first_search(g,seed))} & \tcode{edge_view<VId,true,E,void>} \\
    \tcode{for(auto\&\& [uid,vid,uv,val] : sourced_edges_breadth_first_search(g,seed,evf))} & \tcode{edge_view<VId,true,E,EV>} \\
\hline
\end{tabular}}
\caption{breadth\_first\_search View Functions}
\label{tab:bfs}
\end{center}
\end{table}

\subsubsection{topological\_sort Views}
topological\_sort views iterate over the vertices and edges from a given seed vertex, returning a \tcode{vertex_view} or \tcode{edge_view} on each iteration when it is first encountered, depending on the function used. 
Table \ref{tab:topo_sort} shows the functions and their return values.

While not shown in the examples, all functions have a final, optional allocator parameter that defaults to \tcode{std::allocator<bool>}. It is used for containers that are internal to the view. The \tcode{<bool>} argument has no particular meaning.

\begin{table}[h!]
\begin{center}
\resizebox{\textwidth}{!}
{\begin{tabular}{l l}
\hline
    \textbf{Example} & \textbf{Return} \\
\hline
    \tcode{for(auto\&\& [vid,v] : vertices_topological_sort(g,seed))} & \tcode{vertex_view<VId,V,void>} \\
    \tcode{for(auto\&\& [vid,v,val] : vertices_topological_sort(g,seed,vvf))} & \tcode{vertex_view<VId,V,VV>} \\
\hline
    \tcode{for(auto\&\& [vid,uv] : edges_topological_sort(g,seed))} & \tcode{edge_view<VId,false,E,void>} \\
    \tcode{for(auto\&\& [vid,uv,val] : edges_topological_sort(g,seed,evf))} & \tcode{edge_view<VId,false,E,EV>} \\
\hline
    \tcode{for(auto\&\& [uid,vid,uv] : sourced_edges_topological_sort(g,seed))} & \tcode{edge_view<VId,true,E,void>} \\
    \tcode{for(auto\&\& [uid,vid,uv,val] : sourced_edges_topological_sort(g,seed,evf))} & \tcode{edge_view<VId,true,E,EV>} \\
\hline
\end{tabular}}
\caption{topological\_sort View Functions}
\label{tab:topo_sort}
\end{center}
\end{table}

\subsection{Graph Container Interface}
The Graph Container Interface defines the primitive concepts, traits, types and functions used to define and access an adacency graph, no matter its internal design and organization. Thus, it is designed to reflect all forms of adjacency graphs including a vector of lists, CSR graph and adjacency matrix, whether they are in the standard or external to the standard.

All algorithms in this proposal require that vertices are stored in random access containers and that \tcode{vertex_id_t<G>} is integral, and it is assumed that all future algorithm proposals will also have the same requirements. 

The Graph Container Interface is designed to support a wider scope of graph containers than required by the views and algorithms in this proposal. This enables for future growth of the graph data model (e.g. incoming edges on a vertex), or as a framework for graph implementations outside of the standard. For instance, existing implementations may have requirements that cause them to define features with looser constraints, such as sparse vertex\_ids, non-integral vertex\_ids, or storing vertices in associative bi-directional containers (e.g. std::map or std::unordered\_map). Such features require specialized implementations for views and algorithms. The performance for such algorithms will be sub-optimal, but is preferrable to run them on the existing container rather than loading the graph into a high-performance graph container and then running the algorithm on it, where the loading time can far outweigh the time to run the sub-optimal algorithm. To achieve this, care has been taken to make sure that the use of concepts chosen is appropriate for algorithm, view and container.

\subsubsection{Concepts}
Table \ref{tab:graph_concepts} summarizes the concepts in the Graph Container Interface, allowing views and algorithms to verify a graph implementation has the expected requirements for an \tcode{adjacency_list} or \tcode{sourced_adjacency_list}.

Sourced edges have a source\_id on them in addition to a target\_id. A \tcode{sourced_adjacency_list} has sourced edges.

% is_sourced_edge and is_sourced_edge_v structs are not included the table for brevity. We may want to add them in the future for completeness.
\begin{table}[h!]
\begin{center}
%\resizebox{\textwidth}{!}
{\begin{tabular}{l L{12.0cm}}
\hline
    \textbf{Concept} & \textbf{Definition} \\
\hline
    \tcode{vertex_range<G>} & \tcode{vertices(g)} returns a sized, forward\_range; \tcode{vertex_id(g,ui)} exists\\
    \tcode{targeted_edge<G>} & \tcode{target_id(g,uv)} and \tcode{target(g,uv)} exist\\
    \tcode{sourced_edge<G>} & \tcode{source_id(g,uv)} and \tcode{source(g,uv)} exist\\
    \tcode{adjacency_list<G>} & \tcode{vertex_range<G>} and \tcode{targeted_edge<G,edge<G>>} and \tcode{edges(g,_)} functions return a forward\_range\\
    \tcode{sourced_adjacency_list<G>} & \tcode{adjacency_list<G>} and \tcode{sourced_edge<G, edge_t<G>>} and     \tcode{edge_id(g,uv)} exists \\
\hline
    \tcode{copyable_vertex<T,VId,VV>} & \tcode{convertible_to<T, copyable_vertex_t<VId, VV>>} \\
    \tcode{copyable_edge<T,Vid,EV>} & \tcode{convertible_to<T, copyable_edge_t<VId, EV>>} \\
\hline
\end{tabular}}
\caption{Graph Container Interface Concepts}
\label{tab:graph_concepts}
\end{center}
\end{table}

\subsubsection{Traits}
Table \ref{tab:graph_traits} summarizes the type traits in the Graph Container Interface, allowing views and algorithms to query the graph's characteristics.

\begin{table}[h!]
\begin{center}
%\resizebox{\textwidth}{!}
{\begin{tabular}{l l L{7.0cm}}
\hline
    \textbf{Trait} & \textbf{Type} & \textbf{Comment} \\
\hline
    \tcode{has_degree<G>} & concept & Is the \tcode{degree(g,u)} function available? \\
    \tcode{has_find_vertex<G>} & concept & Are the \tcode{find_vertex(g,_)} functions available? \\
    \tcode{has_find_vertex_edge<G>} & concept & Are the \tcode{find_vertex_edge(g,_)} functions available?\\
    \tcode{has_contains_edge<G>} & concept & Is the \tcode{contains_edge(g,uid,vid)} function available?\\
\hline
    \tcode{define_unordered_edge<G,E> : false_type} & struct & Specialize for edge implementation to derive from \tcode{true_type} for unordered edges \\
    \tcode{is_unordered_edge<G,E>} & struct & \tcode{conjunction<define_unordered_edge<E>, is_sourced_edge<G, E>>} \\
    \tcode{is_unordered_edge_v<G,E>} & type alias & \\
    \tcode{unordered_edge<G,E>} & concept & \\
\hline
    \tcode{is_ordered_edge<G,E>} & struct & \tcode{negation<is_unordered_edge<G,E>>} \\
    \tcode{is_ordered_edge_v<G,E>} & type alias & \\
    \tcode{ordered_edge<G,E>} & concept & \\
\hline
    \tcode{define_adjacency_matrix<G> : false_type} & struct & Specialize for graph implementation to derive from \tcode{true_type} for edges stored as a square 2-dimensional array \\
    \tcode{is_adjacency_matrix<G>} & struct & \\
    \tcode{is_adjacency_matrix_v<G>} & type alias & \\
    \tcode{adjacency_matrix<G>} & concept & \\
\hline
\end{tabular}}
\caption{Graph Container Interface Type Traits}
\label{tab:graph_traits}
\end{center}
\end{table}


\subsubsection{Types}
Table \ref{tab:graph_type} summarizes the type aliases in the Graph Container Interface. These are the types used to define the objects in a graph container, no matter its internal design and organization. Thus, it is designed to be able to reflect all forms of adjacency graphs including a vector of lists, CSR graph and adjacency matrix.

The type aliases are defined by either a function specialization for the underlying graph container, or a refinement of one of those types (e.g. an iterator of a range). Table \ref{tab:graph_func} describes the functions in more detail.

\tcode{graph_value(g)}, \tcode{vertex_value(g,u)} and \tcode{edge_value(g,uv)} can be optionally implemented, depending on whether the graph container supports values on the graph, vertex and edge types.

\begin{table}[h!]
\begin{center}
\resizebox{\textwidth}{!}
{\begin{tabular}{l l L{1.5cm}}
\hline
    \textbf{Type Alias} & \textbf{Definition} & \textbf{Comment} \\
\hline
    \tcode{graph_reference_t<G>} & \tcode{add_lvalue_reference<G>} & \\
    \tcode{graph_value_t<G>} & \tcode{decltype(graph_value(g))} & optional \\
\hline
    \tcode{vertex_range_t<G>} & \tcode{decltype(vertices(g))} & \\    
    \tcode{vertex_iterator_t<G>} & \tcode{iterator_t<vertex_range_t<G>>} & \\    
    \tcode{vertex_t<G>} & \tcode{range_value_t<vertex_range_t<G>>} & \\    
    \tcode{vertex_reference_t<G>} & \tcode{range_reference_t<vertex_range_t<G>>} & \\    
    \tcode{vertex_id_t<G>} & \tcode{decltype(vertex_id(g))} & \\    
    \tcode{vertex_value_t<G>} & \tcode{decltype(vertex_value(g))} & optional \\
\hline
    \tcode{vertex_edge_range_t<G>} & \tcode{decltype(edges(g,u))} & \\    
    \tcode{vertex_edge_iterator_t<G>} & \tcode{iterator_t<vertex_edge_range_t<G>>} & \\    
    \tcode{edge_t<G>} & \tcode{range_value_t<vertex_edge_range_t<G>>} & \\    
    \tcode{edge_reference_t<G>} & \tcode{range_reference_t<vertex_edge_range_t<G>>} & \\    
    \tcode{edge_value_t<G>} & \tcode{decltype(edge_value(g))} & optional \\
\hdashline
    \multicolumn{3}{c}{The following is only available when the optional \tcode{source_id(g,uv)} is defined for the edge} \\
\hdashline
    \tcode{edge_id_t<G>} & \tcode{decltype(pair(source_id(g,uv),target_id(g,uv)))} & \\    
\hline
\end{tabular}}
\caption{Graph Container Interface Type Aliases}
\label{tab:graph_type}
\end{center}
\end{table}


\subsubsection{Functions}

\phil{The functions in the Graph Container Interface are semi-stable. New functions are not expected, but overloads may be added or removed for different combinations of 
vertex\_id and references as we refine our use cases.}

Table \ref{tab:graph_func} summarizes the functions in the Graph Container Interface. These are the primitive functions used to access an adacency graph, no matter its internal design and organization. Thus, it is designed to be able to reflect all forms of adjacency graphs including a vector of lists, CSR graph and adjacency matrix.


\begin{table}[h!]
\begin{center}
\resizebox{\textwidth}{!}
{\begin{tabular}{l l p{1.5cm} L{7.0cm}}
\hline
    \textbf{Function} & \textbf{Return Type} & \textbf{Complexity} & \textbf{Default Implementation} \\
\hline
    \tcode{graph_value(g)} & \tcode{graph_value_t<G>} & constant & n/a, optional \\
\hline
    \tcode{vertices(g)} & \tcode{vetex_range_t<G>} & constant & n/a \\
    \tcode{vertex_id(g,ui)} & \tcode{vetex_id_t<G>} & constant & \tcode{ui - begin(vertices(g))} \\
    & & & Override to define a different \tcode{vertex_id_t<G>} type (e.g. int32\_t). \\
    \tcode{vertex_value(g,u)} & \tcode{vertex_value_t<G>} & constant & n/a, optional \\
    \tcode{degree(g,u)} & \tcode{integral} & constant & \tcode{size(edges(g,u))} if \tcode{sized_range<vertex_edge_range_t<G>>} \\
    \tcode{find_vertex(g,uid)} & \tcode{vertex_iterator_t<G>} & constant & \tcode{begin(vertices(g)) + uid} \\
    & & & if \tcode{random_access_range<vertex_range_t<G>>}  \\
\hline
    \tcode{edges(g,u)} & \tcode{vertex_edge_range_t<G>} & constant & n/a \\
    \tcode{edges(g,uid)} & \tcode{vertex_edge_range_t<G>} & constant & \tcode{edges(g,*find_vertex(g,uid))} \\
    \tcode{target_id(g,uv)} & \tcode{vertex_id_t<G>} & constant & n/a \\
    \tcode{target(g,uv)} & \tcode{vertex_t<G>} & constant & \tcode{*(begin(vertices(g)) + target_id(g, uv))} if \tcode{random_access_range<vertex_range_t<G>> \&\& integral<target_id(g,uv)>} \\
    \tcode{edge_value(g,uv)} & \tcode{edge_value_t<G>} & constant & n/a, optional \\
    \tcode{find_vertex_edge(g,u,vid)} & \tcode{vertex_edge_t<G>} & linear & \tcode{find(edges(g,u), [](uv) {target_id(g,uv)==vid;\})}} \\
    \tcode{find_vertex_edge(g,uid,vid)} & \tcode{vertex_edge_t<G>} & linear & \tcode{find_vertex_edge(g,*find_vertex(g,uid),vid)} \\
    \tcode{contains_edge(g,uid,vid)} & \tcode{bool} & constant & \tcode{uid < size(vertices(g)) \&\& vid < size(vertices(g))} if \tcode{is_adjacency_matrix_v<G>}.\\
    & & linear & \tcode{find_vertex_edge(g,uid) != end(edges(g,uid))} otherwise. \\
\hdashline
    \multicolumn{4}{c}{The following are only available when the optional \tcode{source_id(g,uv)} is defined for the edge} \\
\hdashline
    \tcode{source_id(g,uv)} & \tcode{vertex_id_t<G>} & constant & n/a, optional \\
    \tcode{source(g,uv)} & \tcode{vertex_t<G>} & constant & \tcode{*(begin(vertices(g)) + source_id(g,uv))} if \tcode{random_access_range<vertex_range_t<G>> \&\& integral<target_id(g,uv)>} \\
    \tcode{edge_id(g,uv)} & \tcode{edge_id_t<G>} & constant & \tcode{pair(source_id(g,uv),target_id(g,uv))} \\
\hline
\end{tabular}}
\caption{Graph Container Interface Functions}
\label{tab:graph_func}
\end{center}
\end{table}

Functions that have n/a for their Default Implementation must be defined by the author of a Graph Container implementation. \tcode{graph_value(g)}, \tcode{vertex_value(g,u)} and \tcode{edge_value(g,uv)} can be optionally implemented, depending on whether the graph container supports values on the graph, vertex and edge types.

\tcode{vertex_id_t<G>} is defined by the type returned by \tcode{vertex_id(g)} and it defaults to the difference\_type of the underlying container used for vertices (e.g int64\_t for 64-bit systems). This is sufficient for all situations. However, there are often space and performance advantages if a smaller type is used, such as int32\_t or even int16\_t. It is recommended to consider overriding this function for optimal results, assuring that it is also large enough for the number of possible vertices and edges in the application. It will also need to be overridden if the implementation doesn't expose the vertices as a range.

\tcode{find_vertex(g,uid)} is constant complexity because all algorithms in this proposal require that \tcode{vertex_range_t<G>} is a random access range. 

If the concept requirements for the default implementation aren't met by the graph container the function will need to be overridden.

Edgelists are assumed to be either be an edgelist view of an adjacency graph, or a standard range with source\_id and target\_id values. There is no need for additional functions when a range is used.

\subsection{Graph Container Implementation}

\subsubsection{csr\_graph Graph Container}
The csr\_graph is a high-performance graph container that uses \href{https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_\%28CSR\%2C_CRS_or_Yale_format\%29}{Compressed Sparse Row} format to store it's vertices, edges and associated values. Once constructed, vertices and edges cannot be added or deleted but values on vertices and edges can be modified.
\\

The following listing shows the public interface for the \tcode{csr_graph}. 

When a value type template argument (EV, VV, GV) is void then no extra overhead is incurred for it. The selection of the VId template argument impacts the inter storage requirements. If you have a small graph where the number of vertices is less than 256, and the number of edges is less than 256, then a \tcode{uint8_t} would be sufficient.

Only the constructors, destructor and assignment operators for \tcode{csr_graph} are public. No other member functions or types are exposed. All other types are only accessible through the types and functions in the Graph Container Interface.

The \tcode{ERng} template parameter is assumed to be a range of \tcode{copyable_edge_t<VId,EV>}. If it isn't, an \tcode{EProj} projection function must be passed to to convert the ERng value type to a \tcode{copyable_edge_t<VId,EV>}.

Likewise, the \tcode{VRng} template parameter is assumed to be a range of \tcode{copyable_vertex_t<VId,VV>}. If it isn't, a \tcode{VProj} projection function must be passed to convert the VRng value type to a \tcode{copyable_vertex_t<VId,VV>}.

\begin{lstlisting}
template <class    EV    = void,  // Edge Value type
          class    VV    = void,  // Vertex Value type
          class    GV    = void,  // Graph Value type
          integral VId   = uint32_t, 
          class    Alloc = allocator<uint32_t>>
class csr_graph {
public:
  constexpr csr_graph()                 = default;
  constexpr csr_graph(const csr_graph&) = default;
  constexpr csr_graph(csr_graph&&)      = default;
  constexpr ~csr_graph()                = default;

  constexpr csr_graph& operator=(const csr_graph&) = default;
  constexpr csr_graph& operator=(csr_graph&&)      = default;
  
  // edge-only construction
  template <ranges::forward_range ERng, class EProj = identity>
  requires copyable_edge<invoke_result<EProj, ranges::range_value_t<ERng>>, VId, EV>
  constexpr csr_graph(const ERng&  erng, 
                      EProj        eprojection, 
                      const Alloc& alloc = Alloc());

  // edge and vertex value construction
  template <ranges::forward_range ERng, 
            ranges::forward_range VRng, 
            class                 EProj = identity, 
            class                 VProj = identity>
  requires 
        copyable_edge<invoke_result<EProj, ranges::range_value_t<ERng>>, VId, EV> &&
        copyable_vertex<invoke_result<VProj, ranges::range_value_t<VRng>>, VId, VV>
  constexpr csr_graph(const ERng&  erng,
                      const VRng&  vrng,
                      EProj        eprojection = {},
                      VProj        vprojection = {},
                      const Alloc& alloc       = Alloc());

  // initializer list using edge_view<VId,true,void,EV>
  constexpr csr_graph(const initializer_list<copyable_edge_t<VId, EV>>& ilist, 
                      const Alloc& alloc = Alloc());
};
\end{lstlisting}

\subsubsection{csr\_partite\_graph Graph Container (In Design)}
\phil{This is experimental}

The \tcode{csr_partite_graph} extends \tcode{csr_graph} to have multiple partitions, where each partition defines a different value type for the vertex and edge. The same template arguments are used, but it also expects that the VV and EV arguments are \tcode{std::variant}, and the number of types in each is the same. The number of types in the variants define the number of partitions. The edge types apply to the outgoing edges of the vertices in the same partition. \tcode{std::monostate} can be used if no value is needed for a vertex or edge in a partition.

Example usage
\begin{lstlisting}
using VV = std::variant<int,double,bool>;
using EV = std::variant<int,int,std::monostate>; // no outgoing edges in the final partition
using G  = csr_partite_graph<EV, VV>;
G g = ...; // construct g with data
for(size_t p = 0; p < partition_size(g); ++p) {
  for(auto&& [uid,u] : partition(g,p)) {
    for(auto&& [vid,uv] : incidence(g,u)) {
       // do interesting things with uv
    }
  }
}
\end{lstlisting}

\section{Design - Graph Container Author}
\subsection{Customization Points}
Customization Points can be implemented in one of three ways:
\begin{enumerate}
\item A static function object that can be overridden by using ADL. This is the current technique used in existing standard libraries.
\item \href{https://wg21.link/P2547}{P2547 Language Support for Customisable Functions}, an active proposal for C++26.
\item \href{https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1895r0.pdf}{P1895 tag\_invoke: A general pattern for supporting customisable functions}. This has been dismissed as a viable solution for use in the standard for a variety of reasons identified in in P2547.
\end{enumerate}

We are monitoring the progress of P2547 and will use that if is accepted into the Standard. In the interim, the current library prototype implementation is using \tcode{tag_invoke} for convenience, but it will be replaced with the function object or P2547 functionality at a future date.

\subsection{Function Specialization}

\section{Specification}
\section{Library introduction [library]}
\section{Graph introduction [graph]}
\section{algorithms [graph.algorithms]}
\section{views [graph.views]}
\section{customization points [graph.functions]}


\section{Old Introduction (Content after this will be moved above or removed)}

\subsection{Namespaces and Headers}
Graph algorithms, views and containers are unique and not easily interchanged with other elements of the standard library. For
instance, graph algorithms wouldn't be used on a non-graph range. For this reason it is recommended to have them in their own 
namespaces. Suggestions for namespaces are \tcode{std::graph} and
\tcode{std::ranges::graph} for the root namespace. The graph namespaces proposed include
\begin{itemize}
\item[]\tcode{std::graph}
\item[]\tcode{std::graph::views}
\end{itemize}

Proposed headers include
\begin{itemize}
\item[]\tcode{<graph>}
\item[]\tcode{<graph_view>}
\item[]\tcode{<graph_algorithm>}
\item[]\tcode{<csr_graph>}
\end{itemize}

\section{Technical Specifications}
TBA

\subsection{Header \tcode{<graph>} synopsis [graph.syn]}

\begin{lstlisting}
namespace std::graph {

// ...

template <typename G>
auto vertices(G&& g);

template <typename G>
auto vertex_id(G&& g, vertex_iterator_t<G>);

template <typename G>
auto vertex_value(G&& g, vertex_reference_t<G>);

// ...

template <class G>
inline constexpr bool is_adjacency_matrix_v = false;

template <class E>
inline constexpr bool is_undirected_edge_v = false;

template <class G>
concept vertex_range = ranges::forward_range<vertex_range_t<G>> && 
                                   ranges::sized_range<vertex_range_t<G>> &&
requires(G&& g, vertex_iterator_t<G> ui) {
  { vertices(g) } -> ranges::forward_range;
  vertex_id(g, ui);
};

template <class G, class ER>
concept targeted_edge = ranges::forward_range<ER> && 
requires(G&& g, ranges::range_reference_t<ER> uv) {
  target_id(g, uv);
  target(g, uv);
};

template <class G, class ER>
concept sourced_edge = 
requires(G&& g, ranges::range_reference_t<ER> uv) {
  source_id(g, uv);
  source(g, uv);
};

template <class G>
concept adjacency_list = vertex_range<G> && 
                          targeted_edge<G, vertex_edge_range_t<G>> &&   
requires(
      G&& g, vertex_reference_t<G> u, vertex_id_t<G> uid, ranges::range_reference_t<vertex_edge_range_t<G>> uv) {
  { edges(g, u) } -> ranges::forward_range;
  { edges(g, uid) } -> ranges::forward_range;
};

template <class G>
concept sourced_adjacency_list = adjacency_list<G> && sourced_edge<G, vertex_edge_range_t<G>> &&
      requires(G&& g, edge_reference_t<G> uv) {
  edge_id(g, uv);
};

template <class G>
concept undirected_incidence_graph = sourced_adjacency_list<G> && is_undirected_edge_v<edge_t<G>>;

template <class G>
concept directed_incidence_graph = !undirected_incidence_graph<G>;

template <class G>
concept adjacency_matrix = is_adjacency_matrix_v<G>;

template <class G>
concept has_degree = requires(G&& g, vertex_reference_t<G> u) {
  {degree(g, u)};
};

template <class G>
concept has_find_vertex = requires(G&& g, vertex_id_t<G> uid) {
  { find_vertex(g, uid) } -> forward_iterator;
};

template <class G>
concept has_find_vertex_edge = requires(G&& g, vertex_id_t<G> uid, vertex_id_t<G> vid, vertex_reference_t<G> u) {
  { find_vertex_edge(g, u, vid) } -> forward_iterator;
  { find_vertex_edge(g, uid, vid) } -> forward_iterator;
};

template <class G>
concept has_contains_edge = requires(G&& g, vertex_id_t<G> uid, vertex_id_t<G> vid) {
  { contains_edge(g, uid, vid) } -> convertible_to<bool>;
};

}
\end{lstlisting}

\vspace{10pt}

\noindent The following is a synopsis of the functions and classes above.

\begin{lstlisting}
template <typename G>
auto vertices(G&& g);
\end{lstlisting}
%
\begin{itemize}
\item Preconditions: TBA.
\item Effects: TBA.
\item Complexity: TBA.
\item Returns: TBA.
\item Remarks: TBA.
\end{itemize}

\vspace{10pt}

\begin{lstlisting}
template <typename G>
auto vertex_id (G&& g, vertex_iterator_t<G>);
\end{lstlisting}
%
\begin{itemize}
\item Preconditions: TBA.
\item Effects: TBA.
\item Complexity: TBA.
\item Returns: TBA.
\item Remarks: TBA.
\end{itemize}

\vspace{10pt}

\begin{lstlisting}
template <typename G>
auto vertex_value (G&& g, vertex_reference_t<G>);
\end{lstlisting}
%
\begin{itemize}
\item Preconditions: TBA.
\item Effects: TBA.
\item Complexity: TBA.
\item Returns: TBA.
\item Remarks: TBA.
\end{itemize}

\subsection{Header \tcode{<graph_view>} synopsis [graph.syn]}

\begin{lstlisting}
namespace std::graph::views {

// ...

template <typename G>
auto vertexlist(G&& g);

template <typename G>
auto incidence(G&& g, vertex_reference_t<G>);

template <typename G>
auto neighbors(G&& g, vertex_reference_t<G>);

template <typename G>
auto edgelist(G&& g);

// ...
// vertices_depth_first_search
// edges_depth_first_search
// sourced_edges_depth_first_search
// vertices_breadth_first_search
// edges_breadth_first_search
}
\end{lstlisting}

\subsection{Header \tcode{<graph_algorithm>} synopsis [graph.syn]}

\begin{lstlisting}
namespace std::graph {

// ...

}
\end{lstlisting}

\subsection{Header \tcode{<csr_graph>} synopsis [graph.syn]}

\begin{lstlisting}
namespace std::graph {

// ...

template<class EV, class VV, class GV, class VId, class Alloc>
class csr_graph;

// ...
}
\end{lstlisting}


\section{Acknowledgements}
Michael Wong's work is made possible by Codeplay Software Ltd., ISOCPP Foundation, Khronos and the Standards Council of Canada.  The authors wish to further thank the members of SG19 for their contributions.

\footnotesize
\bibliographystyle{unsrt}
\bibliography{P1709R4}
\normalsize

\end{document}
