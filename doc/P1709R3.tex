\documentclass[10pt,onecolumn]{article}

\usepackage[
	left=0.9in,
	top=1.0in,
	right=0.9in,
	bottom=1.0in]{geometry}
\usepackage{soul}
\usepackage{times}
\usepackage[scaled=.90]{helvet} % Use helvetica for sf and scale to proper size

%% \usepackage{url}  %% use hyperref instead

%% Define colors
\usepackage[hyperref]{xcolor}

\definecolor{light-gray}{gray}{0.95}
\definecolor{medium-gray}{gray}{0.33}

\definecolor{bs_keyword}{HTML}{990055} % {D33682} 
\definecolor{bs_name_function}{HTML}{0077AA} % {268BD2}
\definecolor{bs_comment_single}{HTML}{708090} % {2AA198}
\definecolor{bs_name}{HTML}{0077AA} % {2AA198}
\definecolor{bs_number}{HTML}{000000}
\definecolor{bs_string}{HTML}{A67F59}
\definecolor{bs_highlight_background}{HTML}{F2F2F2}
\definecolor{bs_h1_h2_h3}{HTML}{005A9C}
\definecolor{bs_a_href}{HTML}{034575}
\definecolor{comment}{HTML}{0000A0}

%% Customize section headings
\usepackage{titlesec}
\titleformat*{\section}{\normalfont\Large\bfseries\color{bs_h1_h2_h3}}
\titleformat*{\subsection}{\normalfont\large\bfseries\color{bs_h1_h2_h3}}
\titleformat*{\subsubsection}{\normalfont\normalsize\bfseries\color{bs_h1_h2_h3}}

%% Customize hyperlinks
\usepackage{hyperref}
\hypersetup{
  colorlinks = true,
  linkcolor = bs_h1_h2_h3% {0 .35 .61} % 005A9C
}

%% Customize code formatting
%% Note that P2300 uses Menlo, Consolas, "DejaVu Sans Mono", Monaco, monospace;
%% TODO (maybe)
%% To use with XeLaTeX:
%% \usepackage{fontspec}
%% \newfontfamily{\lstsansserif}[Scale=.85]{Menlo}
%% \lstset{basicstyle=\lstsansserif}
%% To handle numbers:
%% cf. https://tex.stackexchange.com/questions/34896/coloring-digits-with-the-listings-package
\usepackage{listings}
\lstset
{
  language=[11]C++,
  backgroundcolor=\color{bs_highlight_background},
  basicstyle=\ttfamily, % \bf\ttfamily,
  breaklines=true,
  commentstyle=\color{bs_comment_single},
  keywordstyle=\color{bs_keyword},
  identifierstyle=\color{bs_name_function},
  stringstyle=\color{bs_string},
  frame=single,
  framerule=0pt,
  showstringspaces=false
}

%% Keywords for C++20
\lstset{
  morekeywords = {
    char8_t,
    concept,
    consteval,
    co_await,
    co_return,
    co_yield,
    requires,
    import,
    module
  }
}

%% \lstset{
%%   emph = { % [20]
%%     import,
%%     module
%%   }
%% }

%% Shortcut for inline code
\newcommand{\tcode}[1]{\lstinline[breaklines=true]{#1}}

\newcommand{\comment}[2]{{\color{comment}[{\sc #1:} \textsf{#2}]}}
\newcommand{\phil}[1]{\comment{Phil}{#1}}
\newcommand{\andrew}[1]{\comment{Andrew}{#1}}



\begin{document}

\begin{titlepage}
~
\vfill
\begin{center}
\LARGE
\textbf{P1709R3 Graph Library}\\
\vspace{12pt}
\normalsize
	Phillip Ratzloff (SAS Institute)\\
	Andrew Lumsdaine (TileDB/University of Washington)\\
	Richard Dosselmann (University of Regina)\\
	Michael Wong (Codeplay)\\
	Matthew Galati (SAS Institute)\\	
	Jens Maurer\\
	Domagoj Saric\\
	Jesun Firoz\\
	Kevin Deweese\\
\end{center}
\vspace{32pt}
\begin{tabular}{ll}
\textbf{Document Number:} & P1709R3\\
\textbf{Date:} & \hl{May 12}, 2022 (mailing)\\ 
\textbf{Project:} & ISO JTC1/SC22/WG21: Programming Language C++\\
\textbf{Audience:} & SG19, WG21, LEWG\\
\textbf{Emails:}
	&\texttt{Phil.Ratzloff@sas.com}\\
	&\texttt{Andrew.Lumsdaine@tiledb.com}\\
	&\texttt{dosselmr@cs.uregina.ca}\\
	&\texttt{michael@codeplay.com}\\
	&\texttt{Matthew.Galati@sas.com}\\
\textbf{Reply to:}
	&\texttt{\textbf{Phil.Ratzloff@sas.com}}\\
\end{tabular}
\vfill
~
\end{titlepage}

\tableofcontents

\clearpage

\section{Introduction}
This document proposes the addition of \textbf{graph algorithms}, \textbf{graph views} and a \textbf{graph data structure} to the C++ library to support \textbf{machine learning} (ML), as well as other applications. ML is a large and growing field, both in the \textbf{research community} and \textbf{industry}, that has received a great deal of attention in recent years. This paper presents an \textbf{interface} of the proposed algorithms, views, graph functions and data structures.

\subsection{Motivation}
A graph data structure, used in ML and other \textbf{scientific} domains, as well as \textbf{industrial} and \textbf{general} programming, does \textbf{not} presently exist in the C++ standard. In ML, a graph forms the underlying structure of an \textbf{artificial neural network} (ANN). In a \textbf{game}, a graph can be used to
represent the \textbf{map} of a game world. In \textbf{business} environments, graphs arise as \textbf{entity relationship diagrams} (ERD) or \textbf{data flow diagrams} (DFD). In the realm of \textbf{social media}, a graph represents a \textbf{social network}.

\subsection{Definitions}
adjacency graph, edgelist, vertex, edge

\subsection{Priorities}
\begin{itemize}
\item Follow the separation of algorithms, views, ranges and data structures established by the standard library.
\item Graph algorithms have the following characteristics
\begin{itemize}
\item Support syntax that is simple, expressive and easy to understand. This should not compromise the ability to write high-performance algorithms.
\item Algorithms in this proposal require vertices to be in random access containers with an integral vertex\_id.
\end{itemize}
\item Define views for common traversal of a graph including vertexlist, incidence edges on a vertex, neighboring vertices of a vertex, edgelist, depth-first search and breadth-first search.
\item A graph can be implemented in a wide variety of ways and a common data model is required that can represent them. The graph data model in this proposal supports the following features
\begin{itemize}
\item An adjacency graph data structure, which is an outer range of vertices with an inner range of outgoing (a.k.a. incidence) edges on each vertex. 
\item An edgelist data structure, which is all edges in a graph (e.g. edgelist view), or as container with a source\_id, target\_id and optional value.
\item Definition of concepts, types, type aliases, and functions used by views and algorithms. This is referred to as the \textbf{Graph API}.
\begin{itemize}
\item Graphs external to the standard can override a subset of the functions (customization point objects) to adapt the graph for use by the standard algorithms and views.
\item Type aliases can be overridden for each graph data structure to give additional information that can be used by algorithms to refine their behavior, such as adjacency\_matrix and undirected\_edge.
\end{itemize}
\item Support of optional user-defined value types on an edge, vertex and/or the graph itself.
\item Allow for useful extensions of the data model in future proposals or in external graph implementations. Examples include supporting incoming edges on a vertex, storing vertices in non-random-access containers, and vertices with non-integral keys.
\end{itemize}
\item Provide an initial suite of useful functionality that includes algorithms, views and one graph data structure.
\end{itemize}

\subsection{Examples}
\subsubsection{Example: End User}
\subsubsection{Example: Algorithm}

\subsection{What this proposal is  \textbf{not}}
This paper limits itself to adjacency graphs only, including an outer range of vertices with an inner range of outgoing edges on each vertex. It also includes an edgelist of all edges in the graph. It does not include incoming edges on a vertex, though that could be a future extension.

It does not include hypergraphs.

\hl{TBD: Bipartite graphs?}

\subsection{Prior Art}
boost::graph \\
\hl{Other?}

\subsubsection{Inspirations}
NWGraph

\subsection{Revision History}
\subsubsection*{P1709R3}
\hl{R3 was never published.}
Simplifiy the Graph API by focusing on functionality needed for an incidence graph, removing mutable functions and removing unnecessary functions. Replaced the \tcode{vertex_vertex_range} and \tcode{edge_range} with \tcode{neighbors} and \tcode{edgelist} Graph Views and added new \tcode{vertexlist} and \tcode{incidence} views. Simplified concepts and graph traits.

\subsubsection*{P1709R2}
Define the \textbf{uniform API} for undirected and directed algorithms (an extended API also exists for directed graphs). Added \textbf{concepts} for undirected, directed and bidirected graphs. Refined \textbf{DFS} and \textbf{BFS} range definitions from prototype experience. Refined \textbf{shortest paths} and \textbf{transitive closure} algorithms from input and prototype experience.

\subsubsection*{P1709R1}
Rewrite with a focus on a \textbf{purely functional design}, emphasizing the algorithms and graph API. Also added \textbf{concepts} and \textbf{ranges} into the design. Addressed concerns from Cologne review to change to functional design.

\subsubsection*{P1709R0}
Focus on \textbf{object-oriented API} for data structures and example code for a few algorithms.

\section{Design - Introduction}
\section{Design - User Side}
\subsection{Algorithms}
\subsubsection{Shortest Paths}
\paragraph{Dijkstra's Algorithm}
Dijkstra's algorithm \cite{REF_} ...

\paragraph{Bellman-Ford Algorithm}
The Bellman-Ford algorithm \cite{REF_} ...

\subsubsection{Components}
\paragraph{Connected Components}
Connected components \cite{REF_} ...

\paragraph{Strongly Connected Components}
Strongly connected components \cite{REF_} ...

\paragraph{Biconnected Components}
Biconnected components \cite{REF_} ...

\paragraph{Articulation Points}
Articulation points \cite{REF_} ...

\subsubsection{[Other Algorithms}
\paragraph{[TBD] page\_rank}
\paragraph{[TBD] betweenness\_centrality}
\paragraph{[TBD] triangle\_count}
\paragraph{[TBD] subgraph\_isomorphism}
\subsubsection{Minimum Spanning Tree}
\paragraph{[TBD] kruskell\_minimum\_spanning\_tree}
\paragraph{[TBD] prim\_minimum\_spanning\_tree}
\subsubsection{Community Detection}
\paragraph{[TBD] Louvain}
\paragraph{[TBD] Label propagation}

\subsection{Views}
\subsubsection{vertexlist view}
\subsubsection{incidence view}
\subsubsection{neighbor view}
\subsubsection{edgelist view}
\subsubsection{depth\_first\_search views}
\subsubsection{breadth\_first\_search views}
\subsection{Graph API}
\subsubsection{Concepts and traits}
\subsubsection{Types}
\subsubsection{Functions}
\section{Design - graph data structure side}
\subsection{Function Specialization}
\section{Specification}
\section{Library introduction [library]}
\section{Graph introduction [graph]}
\section{algorithms [graph.algorithms]}
\section{views [graph.views]}
\section{customization points [graph.functions]}


\section{Old Introduction (Content after this will be moved above or removed)}
\section{Impact on the Standard}
This proposal is a pure \textbf{library} extension.

\subsection{Graph}
 A \textit{graph} \cite{REF_graph} $G = (V, E)$ is a set of \textit{vertices} \cite{REF_graph} $V$, \textbf{points} in a space, and \textit{edges} \cite{REF_graph} $E$, \textbf{links} between these vertices. Edges may or may not be \textbf{oriented}, that is, \textit{directed} \cite{REF_graph} or \textit{undirected} \cite{REF_graph}, respectively. Moreover, edges may be \textit{weighted} \cite{REF_graph}, that is, assigned a value. Both \textbf{static} and \textbf{dynamic} implementations of a graph exist, specifically a (static) \textbf{matrix}, each having the typical advantages and disadvantages associated with static and dynamic data structures.

\subsection{Algorithms}
TBA

%\subsubsection{Other Algorithms}
%The following algorithms have been identified for consideration in (an) \textbf{additional} paper(s).
%
%\begin{enumerate}
%\item Minimum spanning tree
%\item Maximum flow
%\item Matching
%\item Bipartite matching
%\item Min-cost network flow
%\item Isomorphism
%\item Subgraph isomorphism
%\item Centrality
%\item Minimum cut
%\item Cycle detection
%\item Path enumeration
%\item Community detection
%\item Clique enumeration
%\item Find triangles
%\item Lowest common ancestor
%\item Dominator algorithms
%\end{enumerate}

\subsection{Views}
TBA

\subsection{Graph Types, Traits, Concepts and Functions}
TBA

\subsection{\tcode{csr_graph} Data Structure}
TBA

\section{Design Decisions}
\subsection{Graph Library Organization}
A physical graph is made up of a range of vertices, where each vertex has a range of edges. This is known as an Incidence Graph. There are a variety of 
ways it can be implemented and such a description is outside the scope of this paper. All implementations share a common interface represented by the
Graph API in this paper.

The Graph API is a set of types, traits and concepts that describe a graph, and a set of functions that provide low-level access to the 
underlying graph with the following characteristics:
\begin{enumerate}
\item All functions are Customization Point Objects (CPO) that can be overridden to integrate a graph with this library. 
6-9 functions must be overridden for a graph data structure to fully integrate with this library, and more functions are available if needed. This proposal includes 
\tcode{csr_graph}, a static graph for performance, that demonstrates how CPOs are overridden.
\item The graph types are defined by the return types of the graph functions, or derivative of them.
\item User-defined value types can be defined for the edge, vertex and graph types. A type of \tcode{void} is assumed if no type has been defined.
Unlike existing containers in the standard, the type is optional. Not all algorithms require values on an edge or vertex, simply using the relationships
between vertices as defined by edges.
\end{enumerate}

Graph Views are built on top of the Graph API and provide common ways for algorithms to iterate through the objects of a graph:
\begin{enumerate}
\item \tcode{views::vertexlist(g)} returns a range of \tcode{views::vertex_view}, for the vertices in the graph. 
\item \tcode{views::incidence(g,u)} returns a range of \tcode{views::edge_view}, for the edges of a source vertex.
\item \tcode{views::neighbors(g,u)} returns a range of \tcode{views::neighbor_view}, for the neighboring vertices of a source vertex.
\item \tcode{views::edgelist(g)} returns a range of \tcode{views::edge_view}, for all the edges of a graph. 
\end{enumerate}

Graph Algorithms use Graph Views (and the Graph API as needed) to traverse the graph to acheive its goal. If an algorithm needs a value from 
a vertex or edge, it should accept a function object that retreives the value. It should never call \tcode{vertex_value(g,u)} or \tcode{edge_value(g,uv)}
directly.

Like the Standard Telmplate Library (STL), algorithms and data structures can be implemented independently and be used interchangeably,
as long as the data structure meets the concept constraints defined by an algorithm.

A graph can be tagged with type aliases to describe underlying characteristics that can be used by an algorithm. Two examples
in this proposal include \tcode{is_undirected_edge_v<E>} and \tcode{is_adjacency_matrix_v<G>}.

\subsection{Separation of Graph Algorithm and Data Structure Requirements}

There are a wide variety of ways to represent a graph that can include both outgoing and incoming edges, undirected edges,
sparse vertex ids, non-numeric vertex ids, etc. However, it is necessary to constrain the design to focus on providing reasonable 
value for the widely accepted algorithms currently available for graphs. With that in mind, the following guidelines have been established.
\begin{enumerate}
\item Graph data structures are assumed to have vertices in a sized \tcode{forward_range}, and edges in an unsized \tcode{forward_range}.
\item Algorithms in this proposal will target a subset of graphs with vertices in a sized \tcode{random_acccess_range} with 
integral ids, and edges will be in a \tcode{forward_range}, for simplicity and performance. Algorithms may require edges to be sized as
needed. It is anticipated that future algorithm proposals will continue to follow these requirements.
\item Views follow the same requirements as the algorithms.
\end{enumerate}

The discrepancy between these definitions is to enable a wider variety of algorithms and graph data structures outside the standard that 
can leverage the underlying design. For instance, the following should be possible in graphs and algorithms outside of this proposal:

\begin{enumerate}
\item Incoming edges could exist for vertices, in addition to the existing incidence, or outgoing, edges for a bi-directed graph.
\item Vertices could be stored in a \tcode{map}, \tcode{unordered_map} or similar data structure for sparse, non-contiguous ids.
\andrew{I (strongly) think this should not be allowed.  If the outer range of a graph is required to be a random-access range, it won't be.  The reason I don't think it should be allowed is that having non-constant time lookup of vertices in the outer range will change the computational complexity of the algorithms---something users will not expect.}
\phil{I support that all algorithms in the standard will require a random access range, but the requirement for it belongs on the algorithm, not the outer range itself. Allowing the outer range to be bidirectional will allow the use of data structures and algoritthms to be used
outside the standard that don't offer the same performance guarantees (e.g. O(log n) access). Accepting that the performance of such a situation is less than optimal, it is better than having nothing at all if we prevent it from happening.}
\item Non-integral ids could be used, such as strings or compound types, that follow the comparison requirements of the vertex container.  \andrew{Similarly here---if this results in non-constant time lookup it is changing the algorithmic complexity.} 
\phil{I expect algorithms in the standard to always use integral id's and is part of the algorithms, not the data structures.  This is a similar argument as before, where we should support a broader set of functionality outside of the standard.}
\item Edges could be stored in a map or set, ordered on the neighbor id, for faster neighbor lookup.
  \andrew{Similarly here.  Traversal of a neighbor list must be linear time in number of neighbors for correct algorithmic complexity.}
  \phil{Use of map or set will not impact linear time for traversing edges in this case. Again, this is to support broader functionality outside of the standard.}
\end{enumerate}

Such features can be important for embedded graph implementations in domain-specific cases and this proposal should not prevent them. 
Future papers could consider proposing these features.
\andrew{We could consider allowing these kinds of things, with suitable warnings in the documentation about computational complexity.  This is similar to doing \tcode{binary_search} on a forward range---I guess the standard allows it, but in the fine print the standard notes that \tcode{binary_search} is then a linear search rather than a binary search.}
\phil{I don't expect us to use it. I suppose we could make a statement that anything that goes outside of the O(1) for vertices would have an impact, but it's outside of our design.} 
\phil{What I'm stating isn't anything different than I've said already. Maybe it needs to be restated to assure the reader?}

\subsection{Customization Point Objects}
All functions for the Graph API, Views and Algorithms are defined as Customization Point Objects (CPO), allowing them to be overriden for
specific graphs. \tcode{tag_invoke} is used to implement the CPO functions.

\subsection{Namespaces and Headers}
Graph algorithms, views and data structures are unique and not easily interchanged with other elements of the standard library. For
instance, graph algorithms wouldn't be used on a non-graph range. For this reason it is recommended to have them in their own 
namespaces. Suggestions for namespaces are \tcode{std::graph} and
\tcode{std::ranges::graph} for the root namespace. The graph namespaces proposed include
\begin{itemize}
\item[]\tcode{graph}
\item[]\tcode{graph::tag_invoke}
\item[]\tcode{graph::views}
\item[]\tcode{graph::views::tag_invoke}
\end{itemize}

Proposed headers include
\begin{itemize}
\item[]\tcode{<graph>}
\item[]\tcode{<graph_view>}
\item[]\tcode{<graph_algorithm>}
\item[]\tcode{<csr_graph>}
\end{itemize}

\section{Technical Specifications}
TBA

\subsection{Header \tcode{<graph>} synopsis [graph.syn]}

\begin{lstlisting}
namespace std::graph {

// ...

template <typename G>
auto vertices(G&& g);

template <typename G>
auto vertex_id(G&& g, vertex_iterator_t<G>);

template <typename G>
auto vertex_value(G&& g, vertex_reference_t<G>);

// ...

template <class G>
inline constexpr bool is_adjacency_matrix_v = false;

template <class E>
inline constexpr bool is_undirected_edge_v = false;

template <class G>
concept vertex_range = ranges::forward_range<vertex_range_t<G>> && 
                                   ranges::sized_range<vertex_range_t<G>> &&
requires(G&& g, vertex_iterator_t<G> ui) {
  { vertices(g) } -> ranges::forward_range;
  vertex_id(g, ui);
};

template <class G, class ER>
concept targeted_edge = ranges::forward_range<ER> && 
requires(G&& g, ranges::range_reference_t<ER> uv) {
  target_id(g, uv);
  target(g, uv);
};

template <class G, class ER>
concept sourced_edge = 
requires(G&& g, ranges::range_reference_t<ER> uv) {
  source_id(g, uv);
  source(g, uv);
};

template <class G>
concept incidence_graph = vertex_range<G> && 
                          targeted_edge<G, vertex_edge_range_t<G>> &&   
requires(
      G&& g, vertex_reference_t<G> u, vertex_id_t<G> uid, ranges::range_reference_t<vertex_edge_range_t<G>> uv) {
  { edges(g, u) } -> ranges::forward_range;
  { edges(g, uid) } -> ranges::forward_range;
};

template <class G>
concept sourced_incidence_graph = incidence_graph<G> && sourced_edge<G, vertex_edge_range_t<G>> &&
      requires(G&& g, edge_reference_t<G> uv) {
  edge_id(g, uv);
};

template <class G>
concept undirected_incidence_graph = sourced_incidence_graph<G> && is_undirected_edge_v<edge_t<G>>;

template <class G>
concept directed_incidence_graph = !undirected_incidence_graph<G>;

template <class G>
concept adjacency_matrix = is_adjacency_matrix_v<G>;

template <class G>
concept has_degree = requires(G&& g, vertex_reference_t<G> u) {
  {degree(g, u)};
};

template <class G>
concept has_find_vertex = requires(G&& g, vertex_id_t<G> uid) {
  { find_vertex(g, uid) } -> forward_iterator;
};

template <class G>
concept has_find_vertex_edge = requires(G&& g, vertex_id_t<G> uid, vertex_id_t<G> vid, vertex_reference_t<G> u) {
  { find_vertex_edge(g, u, vid) } -> forward_iterator;
  { find_vertex_edge(g, uid, vid) } -> forward_iterator;
};

template <class G>
concept has_contains_edge = requires(G&& g, vertex_id_t<G> uid, vertex_id_t<G> vid) {
  { contains_edge(g, uid, vid) } -> convertible_to<bool>;
};

}
\end{lstlisting}

\vspace{10pt}

\noindent The following is a synopsis of the functions and classes above.

\begin{lstlisting}
template <typename G>
auto vertices(G&& g);
\end{lstlisting}
%
\begin{itemize}
\item Preconditions: TBA.
\item Effects: TBA.
\item Complexity: TBA.
\item Returns: TBA.
\item Remarks: TBA.
\end{itemize}

\vspace{10pt}

\begin{lstlisting}
template <typename G>
auto vertex_id (G&& g, vertex_iterator_t<G>);
\end{lstlisting}
%
\begin{itemize}
\item Preconditions: TBA.
\item Effects: TBA.
\item Complexity: TBA.
\item Returns: TBA.
\item Remarks: TBA.
\end{itemize}

\vspace{10pt}

\begin{lstlisting}
template <typename G>
auto vertex_value (G&& g, vertex_reference_t<G>);
\end{lstlisting}
%
\begin{itemize}
\item Preconditions: TBA.
\item Effects: TBA.
\item Complexity: TBA.
\item Returns: TBA.
\item Remarks: TBA.
\end{itemize}

\subsection{Header \tcode{<graph_view>} synopsis [graph.syn]}

\begin{lstlisting}
namespace std::graph::views {

// ...

template <typename G>
auto vertexlist(G&& g);

template <typename G>
auto incidence(G&& g, vertex_reference_t<G>);

template <typename G>
auto neighbors(G&& g, vertex_reference_t<G>);

template <typename G>
auto edgelist(G&& g);

// ...
// vertices_depth_first_search
// edges_depth_first_search
// sourced_edges_depth_first_search
// vertices_breadth_first_search
// edges_breadth_first_search
}
\end{lstlisting}

\subsection{Header \tcode{<graph_algorithm>} synopsis [graph.syn]}

\begin{lstlisting}
namespace std::graph {

// ...tag_invoke


// ...
}
\end{lstlisting}

\subsection{Header \tcode{<csr_graph>} synopsis [graph.syn]}

\begin{lstlisting}
namespace std::graph {

// ...

template<class EV, class VV, class GV, class VId, class Alloc>
class csr_graph;

// ...
}
\end{lstlisting}


\section{Acknowledgements}
Michael Wong's work is made possible by Codeplay Software Ltd., ISOCPP Foundation, Khronos and the Standards Council of Canada.  The authors wish to further thank the members of SG19 for their contributions.

\footnotesize
\bibliographystyle{unsrt}
\bibliography{P1709R3}
\normalsize

\end{document}
