\documentclass[10pt,onecolumn]{article}

\usepackage[
	left=0.75in,
	top=0.75in,
	right=0.75in,
	bottom=0.75in]{geometry}
\usepackage{soul}
\usepackage{times}
\usepackage[scaled=.90]{helvet} % Use helvetica for sf and scale to proper size

%% \usepackage{url}  %% use hyperref instead

%% Define colors
\usepackage[hyperref]{xcolor}

\definecolor{light-gray}{gray}{0.95}
\definecolor{medium-gray}{gray}{0.33}

\definecolor{bs_keyword}{HTML}{990055} % {D33682} 
\definecolor{bs_name_function}{HTML}{0077AA} % {268BD2}
\definecolor{bs_comment_single}{HTML}{708090} % {2AA198}
\definecolor{bs_name}{HTML}{0077AA} % {2AA198}
\definecolor{bs_number}{HTML}{000000}
\definecolor{bs_string}{HTML}{A67F59}
\definecolor{bs_highlight_background}{HTML}{F2F2F2}
\definecolor{bs_h1_h2_h3}{HTML}{005A9C}
\definecolor{bs_a_href}{HTML}{034575}
\definecolor{comment}{HTML}{0000A0}

%% Customize section headings
\usepackage{titlesec}
\titleformat*{\section}{\normalfont\Large\bfseries\color{bs_h1_h2_h3}}
\titleformat*{\subsection}{\normalfont\large\bfseries\color{bs_h1_h2_h3}}
\titleformat*{\subsubsection}{\normalfont\normalsize\bfseries\color{bs_h1_h2_h3}}

%% Customize hyperlinks
\usepackage{hyperref}
\hypersetup{
  colorlinks = true,
  linkcolor = bs_h1_h2_h3% {0 .35 .61} % 005A9C
}

%% Customize code formatting
%% Note that P2300 uses Menlo, Consolas, "DejaVu Sans Mono", Monaco, monospace;
%% TODO (maybe)
%% To use with XeLaTeX:
%% \usepackage{fontspec}
%% \newfontfamily{\lstsansserif}[Scale=.85]{Menlo}
%% \lstset{basicstyle=\lstsansserif}
%% To handle numbers:
%% cf. https://tex.stackexchange.com/questions/34896/coloring-digits-with-the-listings-package
\usepackage{listings}
\lstset
{
  language=[11]C++,
  backgroundcolor=\color{bs_highlight_background},
  basicstyle=\ttfamily, % \bf\ttfamily,
  breaklines=true,
  commentstyle=\color{bs_comment_single},
  keywordstyle=\color{bs_keyword},
  identifierstyle=\color{bs_name_function},
  stringstyle=\color{bs_string},
  frame=single,
  framerule=0pt,
  showstringspaces=false
}

%% Keywords for C++20
\lstset{
  morekeywords = {
    char8_t,
    concept,
    consteval,
    co_await,
    co_return,
    co_yield,
    requires,
    import,
    module
  }
}

%% \lstset{
%%   emph = { % [20]
%%     import,
%%     module
%%   }
%% }

\usepackage{array}
\newcolumntype{L}[1]{>{\raggedright\arraybackslash}p{#1}}
\newcolumntype{R}[1]{>{\raggedleft\arraybackslash}p{#1}}

\usepackage{arydshln}
\usepackage{graphicx}

%% Shortcut for inline code
\newcommand{\tcode}[1]{\lstinline[breaklines=true]{#1}}

\newcommand{\comment}[2]{{\color{comment}[{\sc #1:} \textsf{#2}]}}
\newcommand{\phil}[1]{\comment{Phil}{#1}}
\newcommand{\andrew}[1]{\comment{Andrew}{#1}}



\begin{document}

\begin{titlepage}
~
\vfill
\begin{center}
\LARGE
\textbf{P1709R3 Graph Library}\\
\vspace{12pt}
\normalsize
	Phillip Ratzloff (SAS Institute)\\
	Andrew Lumsdaine (TileDB/University of Washington)\\
	Richard Dosselmann (University of Regina)\\
	Michael Wong (Codeplay)\\
	Matthew Galati (SAS Institute)\\	
	Jens Maurer\\
	Domagoj Saric\\
	Jesun Firoz\\
	Kevin Deweese\\
\end{center}
\vspace{32pt}
\begin{tabular}{ll}
\textbf{Document Number:} & P1709R3\\
\textbf{Date:} & \hl{May 12}, 2022 (mailing)\\ 
\textbf{Project:} & ISO JTC1/SC22/WG21: Programming Language C++\\
\textbf{Audience:} & SG19, WG21, LEWG\\
\textbf{Emails:}
	&\texttt{Phil.Ratzloff@sas.com}\\
	&\texttt{Andrew.Lumsdaine@tiledb.com}\\
	&\texttt{dosselmr@cs.uregina.ca}\\
	&\texttt{michael@codeplay.com}\\
	&\texttt{Matthew.Galati@sas.com}\\
\textbf{Reply to:}
	&\texttt{\textbf{Phil.Ratzloff@sas.com}}\\
\end{tabular}
\vfill
~
\end{titlepage}

\tableofcontents

\clearpage

\section{Introduction}
This document proposes the addition of \textbf{graph algorithms}, \textbf{graph views}, \textbf{graph container interface} and a \textbf{graph container implementation} to the C++ library to support \textbf{machine learning} (ML), as well as other applications. ML is a large and growing field, both in the \textbf{research community} and \textbf{industry}, that has received a great deal of attention in recent years. This paper presents an \textbf{interface} of the proposed algorithms, views, graph functions and containers.

\subsection{Motivation}
Graphs, used in ML and other \textbf{scientific} domains, as well as \textbf{industrial} and \textbf{general} programming, do \textbf{not} presently exist in the C++ standard. In ML, a graph forms the underlying structure of an \textbf{artificial neural network} (ANN). In a \textbf{game}, a graph can be used to
represent the \textbf{map} of a game world. In \textbf{business} environments, graphs arise as \textbf{entity relationship diagrams} (ERD) or \textbf{data flow diagrams} (DFD). In the realm of \textbf{social media}, a graph represents a \textbf{social network}.

\subsection{Impact on the Standard}
This proposal is a pure \textbf{library} extension.

\subsection{Goals and Priorities}
\begin{itemize}
\item Follow the separation of algorithms, ranges, views and containers established by the standard library.
\item All free functions should be customization point objects, unless there's a good reason not to. Reasonable default implementations should be provided whenever possible.
\item Graph algorithms have the following characteristics
\begin{itemize}
\item Support syntax that is simple, expressive and easy to understand. This should not compromise the ability to write high-performance algorithms.
\item Vertices are required to be in random access containers with an integral vertex\_id in this proposal.
\end{itemize}
\item Graph views provide common traversals of a graph's vertices and edges that is more concise and consistant than using the graph container interface directly. They include simple traversals like vertexlist (all vertices in the graph) and incidence edges (edges on a vertex), as well as more complex traversals like depth-first and breath-first searches.
\item The Graph Container Interface provides a consistent interface that can be used by algorithms and views. It has the following characteristics:
\begin{itemize}
\item The interface models an adjacency graph container, which is an outer range of vertices with an inner range of outgoing (a.k.a. incidence) edges on each vertex. 
\item Definition of concepts, types, type traits, type aliases, and functions used by algorithms and views.
\begin{itemize}
\item Type traits will be defined that can be overridden for each graph container to give additional hints that can be used by algorithms to refine their behavior, such as adjacency\_matrix and unordered\_edge.
\end{itemize}
\item Support of optional user-defined value types on an edge, vertex and/or the graph itself.
\item Allow for useful extensions of the graph data model in future proposals or in external graph implementations. 
\end{itemize}
\item Provide an initial suite of useful functionality that includes algorithms, views, container interface, and at least one container implementation.
\end{itemize}

\subsection{What this proposal is  \textbf{not}}
This paper limits itself to adjacency graphs only, including an outer range of vertices with an inner range of outgoing edges on each vertex. It also includes an edgelist of all edges in the graph, either as a edgelist view or a simple range with a source\_id and target\_id. It does not include incoming edges on a vertex, though that could be a future extension.

\hl{Bipartite graphs aren't supported directly.} They can be implemented using a runtime-assigned property on a vertex and are a characteristic of the
underlying graph container implementation.

Hypergraphs are not supported.

\subsection{Prior Art}
boost::graph \\
\hl{Other?}

\subsubsection{Inspiration}
NWGraph

\subsection{Revision History}
\subsubsection*{P1709R3}
This was a major redesign that incorporated all the experience and input from the past 3 years.
\begin{itemize}
\item Reduce the scope to focus on an incidence graph with outgoing edges only, and remove mutable interface functions. The distinction between directed and undirected graphs was replaced by overridable types of unordered and ordered edges for a graph implementation type.
\item Simplify the types and interface functions. In particular, const and non-const variations were consolidated to a single definition to handle both cases 
when appropriate.
\item Introduce Views, inspired by NWGraph design, with simpler and cleaner interfaces to traverse a graph, and simplifying the container interface design.
\item Revisit the algorithms to be considered. transitive\_closure has been dropped. The final list hasn't been finalized yet.
\item Replace the two container implementations with csr\_graph.
\end{itemize}

\phil{Though there were several revisions of R3 reviewed by SG19, it was never published. This is the real R3.}

\subsubsection*{P1709R2}
Define the \textbf{uniform API} for undirected and directed algorithms (an extended API also exists for directed graphs). Added \textbf{concepts} for undirected, directed and bidirected graphs. Refined \textbf{DFS} and \textbf{BFS} range definitions from prototype experience. Refined \textbf{shortest paths} and \textbf{transitive closure} algorithms from input and prototype experience.

\subsubsection*{P1709R1}
Rewrite with a focus on a \textbf{purely functional design}, emphasizing the algorithms and graph API. Also added \textbf{concepts} and \textbf{ranges} into the design. Addressed concerns from Cologne review to change to functional design.

\subsubsection*{P1709R0}
Focus on \textbf{object-oriented API} for data structures and example code for a few algorithms.

\section{Design - Introduction}

Table \ref{tab:name_conv} shows the naming conventions used throughout this document. 

\begin{table}[h!]
\begin{center}
{\begin{tabular}{l l l p{6cm}}
\hline
    \textbf{Template} & & & \\
    \textbf{Parameter} & \textbf{Type Alias} & \textbf{Variable Names} & \textbf{Description} \\
\hline
    \tcode{G} & & & Graph \\
    & \tcode{graph_reference_t<G>} & \tcode{g} & Graph reference \\
    \tcode{GV} &  & & Graph Value, value or reference \\
\hline
    \tcode{V} & \tcode{vertex_t<G>} & & Vertex \\
    & \tcode{vertex_reference_t<G>} & \tcode{u, v, x, y} & Vertex reference \\
    \tcode{VId} & \tcode{vertex_id_t<G>} & \tcode{uid, vid} & Vertex id \\
    \tcode{VV} &  \tcode{vertex_value_t<G>} & & Vertex Value, value or reference \\
    \tcode{VR} &  \tcode{vertex_range_t<G>} & & Vertex Range \\
    \tcode{VI} & \tcode{vertex_iterator_t<G>} & \tcode{ui, vi} & Vertex Iterator \\
    \tcode{VVF} & & \tcode{vvf} & Vertex Value Function: vvf(u) $\rightarrow$ value \\
\hline
    \tcode{E} & \tcode{edge_t<G>} & & Edge \\
    & \tcode{edge_reference_t<G>} & \tcode{uv, vw} & Edge reference \\
    \tcode{EV} &  \tcode{edge_value_t<G>} & & Edge Value, value or reference \\
    \tcode{ER} &  \tcode{vertex_edge_range_t<G>} & & Edge Range for edges of a vertex \\
    \tcode{EI} & \tcode{vertex_edge_iterator_t<G>} & \tcode{uvi, vwi} & Edge Iterator for an edge of a vertex \\
    \tcode{EVF} & & \tcode{evf} & Edge Value Function: evf(uv) $\rightarrow$ value \\
\hline
\end{tabular}}
\caption{Naming Conventions for Types and Variables}
\label{tab:name_conv}
\end{center}
\end{table}

\subsection{Graph Data Model}
\subsubsection{Adjacency Graph}
 A \textit{graph} \cite{REF_graph} $G = (V, E)$ is a set of \textit{vertices} \cite{REF_graph} $V$, \textbf{points} in a space, and \textit{edges} \cite{REF_graph} $E$, \textbf{links} between these vertices. Edges may or may not be \textbf{oriented}, that is, \textit{directed} \cite{REF_graph} or \textit{undirected} \cite{REF_graph}, respectively. Moreover, edges may be \textit{weighted} \cite{REF_graph}, that is, assigned a value. Both \textbf{static} and \textbf{dynamic} implementations of a graph exist, specifically a (static) \textbf{matrix}, each having the typical advantages and disadvantages associated with static and dynamic data structures.

%% adjacency graph, vertex, edge
%% incidence, neighbors (adjacency)
%% optional user-defined values for edge, vertex, graph
\subsubsection{Edge List}

\subsection{Examples}
\subsubsection{Example: User}
\subsubsection{Example: Graph Author}

\section{Design - User Side}
\subsection{Algorithms}
\subsubsection{Shortest Paths}
\paragraph{Dijkstra's Algorithm}
Dijkstra's algorithm \cite{REF_} ...

\paragraph{Bellman-Ford Algorithm}
The Bellman-Ford algorithm \cite{REF_} ...

\subsubsection{Components}
\paragraph{Connected Components}
Connected components \cite{REF_} ...

\paragraph{Strongly Connected Components}
Strongly connected components \cite{REF_} ...

\paragraph{Biconnected Components}
Biconnected components \cite{REF_} ...

\paragraph{Articulation Points}
Articulation points \cite{REF_} ...

\subsubsection{Other Algorithms}
\paragraph{[TBD] page\_rank}
\paragraph{[TBD] betweenness\_centrality}
\paragraph{[TBD] triangle\_count}
\paragraph{[TBD] subgraph\_isomorphism}
\subsubsection{Minimum Spanning Tree}
\paragraph{[TBD] kruskell\_minimum\_spanning\_tree}
\paragraph{[TBD] prim\_minimum\_spanning\_tree}
\subsubsection{Community Detection}
\paragraph{[TBD] Louvain}
\paragraph{[TBD] Label propagation}

\subsection{Views}
\subsubsection{vertexlist views}
\subsubsection{incidence views}
\subsubsection{neighbors views}
\subsubsection{edgelist views}
\subsubsection{depth\_first\_search views}
\subsubsection{breadth\_first\_search views}
\subsubsection{topological\_sort views}

\subsection{Graph Container Interface}
The Graph Container Interface defines the primitive concepts, traits, types and functions used to define and access an adacency graph, no matter its internal design and organization. Thus, it is designed to reflect all forms of adjacency graphs including a vector of lists, CSR graph and adjacency matrix, whether they are in the standard or external to the standard.

All algorithms in this proposal require that vertices are stored in random access containers and that \tcode{vertex_id_t<G>} is integral, and it is assumed that all future algorithm proposals will also have the same requirements. 

The Graph Container Interface is designed to support a wider scope of graph containers than required by the views and algorithms in this proposal. This enables for future growth of the graph data model (e.g. incoming edges on a vertex), or as a framework for graph implementations outside of the standard. For instance, existing implementations may have requirements that cause them to define features with looser constraints, such as sparse vertex\_ids, non-integral vertex\_ids, or storing vertices in associative bi-directional containers (e.g. std::map or std::unordered\_map). Such features require specialized implementations for views and algorithms. The performance for such algorithms will be sub-optimal, but is preferrable to run them on the existing container rather than loading the graph into a high-performance graph container and then running the algorithm on it, where the loading time can far outweigh the time to run the sub-optimal algorithm. To achieve this, care has been taken to make sure that the use of concepts chosen is appropriate for algorithm, view and container.

\subsubsection{Concepts}
\subsubsection{Traits}
Table \ref{tab:graph_traits} summarizes the type traits in the Graph Container Interface, allowing views and algorithms to query the graph's characteristics.

\begin{table}[h!]
\begin{center}
%\resizebox{\textwidth}{!}
{\begin{tabular}{l l L{7.0cm}}
\hline
    \textbf{Trait} & \textbf{Definition} & \textbf{Comment} \\
\hline
    \tcode{has_degree<G>} & concept & Is the \tcode{degree(g,u)} function available? \\
    \tcode{has_find_vertex<G>} & concept & Are the \tcode{find_vertex(g,_)} functions available? \\
    \tcode{has_find_vertex_edge<G>} & concept & \\
    \tcode{has_contains_edge<G>} & concept & \\
\hline
    \tcode{unordered_edge<G,E> : false_type} & struct & Specialize for edge implementation to be \tcode{true_type} for unordered edges \\
    \tcode{is_unordered_edge<G,E>} & struct & \\
    \tcode{is_unordered_edge_v<G,E>} & type alias & \\
\hline
    \tcode{is_ordered_edge<G,E>} & struct & \tcode{negation<is_unordered_edge<G,E>>} \\
    \tcode{is_ordered_edge_v<G,E>} & type alias & \\
\hline
    \tcode{adjacency_matrix<G> : false_type} & struct & Specialize for graph implementation to be \tcode{true_type} for edges stored as a square 2-dimensional array \\
    %\tcode{unordered_edge<G>} & struct & \\
    \tcode{is_adjacency_matrix<G>} & struct & \\
    \tcode{is_adjacency_matrix_v<G>} & type alias & \\
\hline
\end{tabular}}
\caption{Graph Container Interface Type Traits}
\label{tab:graph_traits}
\end{center}
\end{table}


\subsubsection{Types}
Table \ref{tab:graph_type} summarizes the type aliases in the Graph Container Interface. These are the types used to define the objects in a graph container, no matter its internal design and organization. Thus, it is designed to be able to reflect all forms of adjacency graphs including a vector of lists, CSR graph and adjacency matrix.

The type aliases are defined by either a function specialization for the underlying graph container, or a refinement of one of those types (e.g. an iterator of a range). Table \ref{tab:graph_func} describes the functions in more detail.

\tcode{graph_value(g)}, \tcode{vertex_value(g,u)} and \tcode{edge_value(g,uv)} can be optionally implemented, depending on whether the graph container supports values on the graph, vertex and edge types.

\begin{table}[h!]
\begin{center}
\resizebox{\textwidth}{!}
{\begin{tabular}{l l L{1.5cm}}
\hline
    \textbf{Type Alias} & \textbf{Definition} & \textbf{Comment} \\
\hline
    \tcode{graph_reference_t<G>} & \tcode{add_lvalue_reference<G>} & \\
    \tcode{graph_value_t<G>} & \tcode{decltype(graph_value(g))} & optional \\
\hline
    \tcode{vertex_range_t<G>} & \tcode{decltype(vertices(g))} & \\    
    \tcode{vertex_iterator_t<G>} & \tcode{iterator_t<vertex_range_t<G>>} & \\    
    \tcode{vertex_t<G>} & \tcode{iterator_t<vertex_range_t<G>>} & \\    
    \tcode{vertex_reference_t<G>} & \tcode{range_reference_t<vertex_range_t<G>>} & \\    
    \tcode{vertex_id_t<G>} & \tcode{decltype(vertex_id(g))} & \\    
    \tcode{vertex_value_t<G>} & \tcode{decltype(vertex_value(g))} & optional \\
\hline
    \tcode{vertex_edge_range_t<G>} & \tcode{decltype(edges(g,u))} & \\    
    \tcode{vertex_edge_iterator_t<G>} & \tcode{iterator_t<vertex_edge_range_t<G>>} & \\    
    \tcode{edge_t<G>} & \tcode{range_value_t<vertex_edge_range_t<G>>} & \\    
    \tcode{edge_reference_t<G>} & \tcode{range_reference_t<vertex_edge_range_t<G>>} & \\    
    \tcode{edge_value_t<G>} & \tcode{decltype(edge_value(g))} & optional \\
\hdashline
    \multicolumn{3}{c}{The following are only available when the optional \tcode{source_id(g,uv)} is defined for the edge} \\
\hdashline
    \tcode{edge_id_t<G>} & \tcode{decltype(pair(source_id(g,uv),target_id(g,uv)))} & \\    
\hline
\end{tabular}}
\caption{Graph Container Interface Type Aliases}
\label{tab:graph_type}
\end{center}
\end{table}


\subsubsection{Functions}

\phil{The functions in the Graph Container Interface are semi-stable. New functions are not expected, but overloads may be added or removed for different combinations of 
vertex\_id and references as we refine our use cases.}

Table \ref{tab:graph_func} summarizes the functions in the Graph Container Interface. These are the primitive functions used to access an adacency graph, no matter its internal design and organization. Thus, it is designed to be able to reflect all forms of adjacency graphs including a vector of lists, CSR graph and adjacency matrix.


\begin{table}[h!]
\begin{center}
\resizebox{\textwidth}{!}
{\begin{tabular}{l l p{1.5cm} L{7.0cm}}
\hline
    \textbf{Function} & \textbf{Return Type} & \textbf{Complexity} & \textbf{Default Implementation} \\
\hline
    \tcode{graph_value(g)} & \tcode{graph_value_t<G>} & constant & n/a, optional \\
\hline
    \tcode{vertices(g)} & \tcode{vetex_range_t<G>} & constant & n/a \\
    \tcode{vertex_id(g,ui)} & \tcode{vetex_id_t<G>} & constant & \tcode{ui - begin(vertices(g))} \\
    & & & Override to define a different \tcode{vertex_id_t<G>} type (e.g. int32\_t). \\
    \tcode{vertex_value(g,u)} & \tcode{vertex_value_t<G>} & constant & n/a, optional \\
    \tcode{degree(g,u)} & \tcode{integral} & constant & \tcode{size(edges(g,u))} if \tcode{sized_range<vertex_edge_range_t<G>>} \\
    \tcode{find_vertex(g,uid)} & \tcode{vetex_range_t<G>} & constant & \tcode{begin(vertices(g)) + uid} \\
    & & & if \tcode{random_access_range<vertex_range_t<G>>}  \\
\hline
    \tcode{edges(g,u)} & \tcode{vertex_edge_range_t<G>} & constant & n/a \\
    \tcode{edges(g,uid)} & \tcode{vertex_edge_range_t<G>} & constant & \tcode{edges(g,*find_vertex(g,uid))} \\
    \tcode{target_id(g,uv)} & \tcode{vertex_id_t<G>} & constant & n/a \\
    \tcode{target(g,uv)} & \tcode{vertex_t<G>} & constant & \tcode{*(begin(vertices(g)) + target_id(g, uv))} if \tcode{random_access_range<vertex_range_t<G>> \&\& integral<target_id(g,uv)>} \\
    \tcode{edge_value(g,uv)} & \tcode{edge_value_t<G>} & constant & n/a, optional \\
    \tcode{find_vertex_edge(g,u,vid)} & \tcode{vertex_edge_t<G>} & linear & \tcode{find(edges(g,u), [](uv) {target_id(g,uv)==vid;\})}} \\
    \tcode{find_vertex_edge(g,uid,vid)} & \tcode{vertex_edge_t<G>} & linear & \tcode{find_vertex_edge(g,*find_vertex(g,uid),vid)} \\
    \tcode{contains_edge(g,uid,vid)} & \tcode{bool} & constant & \tcode{uid < size(vertices(g)) \&\& vid < size(vertices(g))} if \tcode{is_adjacency_matrix_v<G>}.\\
    & & linear & \tcode{find_vertex_edge(g,uid) != end(edges(g,uid))} otherwise. \\
\hdashline
    \multicolumn{4}{c}{The following are only available when the optional \tcode{source_id(g,uv)} is defined for the edge} \\
\hdashline
    \tcode{source_id(g,uv)} & \tcode{vertex_id_t<G>} & constant & n/a, optional \\
    \tcode{source(g,uv)} & \tcode{vertex_t<G>} & constant & \tcode{*(begin(vertices(g)) + source_id(g,uv))} if \tcode{random_access_range<vertex_range_t<G>> \&\& integral<target_id(g,uv)>} \\
    \tcode{edge_id(g,uv)} & \tcode{edge_id_t<G>} & constant & \tcode{pair(source_id(g,uv),target_id(g,uv))} \\
\hline
\end{tabular}}
\caption{Graph Container Interface Functions}
\label{tab:graph_func}
\end{center}
\end{table}

Functions that have n/a for their Default Implementation must be defined by the author of a Graph Container implementation. \tcode{graph_value(g)}, \tcode{vertex_value(g,u)} and \tcode{edge_value(g,uv)} can be optionally implemented, depending on whether the graph container supports values on the graph, vertex and edge types.

\tcode{vertex_id_t<G>} is defined by the type returned by \tcode{vertex_id(g)} and it defaults to the difference\_type of the underlying container used for vertices (e.g int64\_t for 64-bit systems). This is sufficient for all situations. However, there are often space and performance advantages if a smaller type is used, such as int32\_t or even int16\_t. It is recommended to consider overriding this function for optimal results, assuring that it is also large enough for the number of possible vertices and edges in the application. It will also need to be overridden if the implementation doesn't expose the vertices as a range.

\tcode{find_vertex(g,uid)} is constant complexity because all algorithms in this proposal require that \tcode{vertex_range_t<G>} is a random access range. 

If the concept requirements for the default implementation aren't met by the graph container the function will need to be overridden.

Edgelists are assumed to be either be an edgelist view of an adjacency graph, or a standard range with source\_id and target\_id values. There is no need for additional functions when a range is used.

\subsection{csr\_graph Graph Container}

\subsection{Future Directions}
% algorithms: 
% views: 
% containers: adjacency matrix
% data model: incoming edges on a vertex

\section{Design - Graph Container Author}
\subsection{Customization Points}
\phil{This section has been shamelessly copied from P2300r5 with text specific to executors removed or replaced with graph-specific text}

The contemporary technique for customization in the Standard Library is customization point objects. A customization point object, will it look for member functions and then for nonmember functions with the same name as the customization point, and calls those if they match. This is the technique used by the C++20 ranges library. However, it has several unfortunate consequences:

\begin{enumerate}
\item It does not allow for easy propagation of customization points unknown to the adaptor to a wrapped object, which makes writing 
universal adapter types much harder - and this proposal uses quite a lot of those.

\item It effectively reserves names globally. Because neither member names nor ADL-found functions can be qualified with a namespace, 
every customization point object that uses the ranges scheme reserves the name for all types in all namespaces.
\end{enumerate}

This paper proposes to instead use the mechanism described in \href{https://latex-tutorial.com/tutorials/hyperlinks/}{tag\_invoke: A general pattern for supporting customisable functions}:
\tcode{tag_invoke}; the wording for \tcode{tag_invoke} has been incorporated into the proposed specification in this paper.

In short, instead of using globally reserved names, \tcode{tag_invoke} uses the type of the customization point object itself as the mechanism to find customizations. 
It globally reserves only a single name - \tcode{tag_invoke} - which itself is used the same way that ranges-style customization points are used. All other customization 
points are defined in terms of \tcode{tag_invoke}. For example, the customization for \tcode{std::graph::vertices(g)} will call 
\tcode{tag_invoke(std::graph::vertices, g)}, instead of attempting to invoke \tcode{g.vertices()}, and then \tcode{vertices(g)} if the member call is not valid.

Using \tcode{tag_invoke} has the following benefits:

\begin{enumerate}
\item It reserves only a single global name, instead of reserving a global name for every customization point object we define.

\item It is possible to propagate customizations to a subobject, because the information of which customization point is being resolved is in the type of an argument, and not in the name of the function:

\begin{lstlisting}
// forward most customizations to a subobject
template<typename Tag, typename ...Args>
friend auto tag_invoke(Tag && tag, wrapper & self, Args &&... args) {
    return std::forward<Tag>(tag)(self.subobject, std::forward<Args>(args)...);
}

// but override one of them with a specific value
friend auto tag_invoke(specific_customization_point_t, wrapper & self) {
    return self.some_value;
}
\end{lstlisting}

\item It is possible to pass those as template arguments to types, because the information of which customization point is being resolved is in the type. 

\end{enumerate}

\subsection{Function Specialization}

\section{Specification}
\section{Library introduction [library]}
\section{Graph introduction [graph]}
\section{algorithms [graph.algorithms]}
\section{views [graph.views]}
\section{customization points [graph.functions]}


\section{Old Introduction (Content after this will be moved above or removed)}

\subsection{Namespaces and Headers}
Graph algorithms, views and containers are unique and not easily interchanged with other elements of the standard library. For
instance, graph algorithms wouldn't be used on a non-graph range. For this reason it is recommended to have them in their own 
namespaces. Suggestions for namespaces are \tcode{std::graph} and
\tcode{std::ranges::graph} for the root namespace. The graph namespaces proposed include
\begin{itemize}
\item[]\tcode{std::tag_invoke}
\item[]\tcode{std::graph}
\item[]\tcode{std::graph::views}
\end{itemize}

Proposed headers include
\begin{itemize}
\item[]\tcode{<graph>}
\item[]\tcode{<graph_algorithm>}
\item[]\tcode{<csr_graph>}
\item[]\tcode{<graph_view>}
\end{itemize}

\section{Technical Specifications}
TBA

\subsection{Header \tcode{<graph>} synopsis [graph.syn]}

\begin{lstlisting}
namespace std::graph {

// ...

template <typename G>
auto vertices(G&& g);

template <typename G>
auto vertex_id(G&& g, vertex_iterator_t<G>);

template <typename G>
auto vertex_value(G&& g, vertex_reference_t<G>);

// ...

template <class G>
inline constexpr bool is_adjacency_matrix_v = false;

template <class E>
inline constexpr bool is_undirected_edge_v = false;

template <class G>
concept vertex_range = ranges::forward_range<vertex_range_t<G>> && 
                                   ranges::sized_range<vertex_range_t<G>> &&
requires(G&& g, vertex_iterator_t<G> ui) {
  { vertices(g) } -> ranges::forward_range;
  vertex_id(g, ui);
};

template <class G, class ER>
concept targeted_edge = ranges::forward_range<ER> && 
requires(G&& g, ranges::range_reference_t<ER> uv) {
  target_id(g, uv);
  target(g, uv);
};

template <class G, class ER>
concept sourced_edge = 
requires(G&& g, ranges::range_reference_t<ER> uv) {
  source_id(g, uv);
  source(g, uv);
};

template <class G>
concept incidence_graph = vertex_range<G> && 
                          targeted_edge<G, vertex_edge_range_t<G>> &&   
requires(
      G&& g, vertex_reference_t<G> u, vertex_id_t<G> uid, ranges::range_reference_t<vertex_edge_range_t<G>> uv) {
  { edges(g, u) } -> ranges::forward_range;
  { edges(g, uid) } -> ranges::forward_range;
};

template <class G>
concept sourced_incidence_graph = incidence_graph<G> && sourced_edge<G, vertex_edge_range_t<G>> &&
      requires(G&& g, edge_reference_t<G> uv) {
  edge_id(g, uv);
};

template <class G>
concept undirected_incidence_graph = sourced_incidence_graph<G> && is_undirected_edge_v<edge_t<G>>;

template <class G>
concept directed_incidence_graph = !undirected_incidence_graph<G>;

template <class G>
concept adjacency_matrix = is_adjacency_matrix_v<G>;

template <class G>
concept has_degree = requires(G&& g, vertex_reference_t<G> u) {
  {degree(g, u)};
};

template <class G>
concept has_find_vertex = requires(G&& g, vertex_id_t<G> uid) {
  { find_vertex(g, uid) } -> forward_iterator;
};

template <class G>
concept has_find_vertex_edge = requires(G&& g, vertex_id_t<G> uid, vertex_id_t<G> vid, vertex_reference_t<G> u) {
  { find_vertex_edge(g, u, vid) } -> forward_iterator;
  { find_vertex_edge(g, uid, vid) } -> forward_iterator;
};

template <class G>
concept has_contains_edge = requires(G&& g, vertex_id_t<G> uid, vertex_id_t<G> vid) {
  { contains_edge(g, uid, vid) } -> convertible_to<bool>;
};

}
\end{lstlisting}

\vspace{10pt}

\noindent The following is a synopsis of the functions and classes above.

\begin{lstlisting}
template <typename G>
auto vertices(G&& g);
\end{lstlisting}
%
\begin{itemize}
\item Preconditions: TBA.
\item Effects: TBA.
\item Complexity: TBA.
\item Returns: TBA.
\item Remarks: TBA.
\end{itemize}

\vspace{10pt}

\begin{lstlisting}
template <typename G>
auto vertex_id (G&& g, vertex_iterator_t<G>);
\end{lstlisting}
%
\begin{itemize}
\item Preconditions: TBA.
\item Effects: TBA.
\item Complexity: TBA.
\item Returns: TBA.
\item Remarks: TBA.
\end{itemize}

\vspace{10pt}

\begin{lstlisting}
template <typename G>
auto vertex_value (G&& g, vertex_reference_t<G>);
\end{lstlisting}
%
\begin{itemize}
\item Preconditions: TBA.
\item Effects: TBA.
\item Complexity: TBA.
\item Returns: TBA.
\item Remarks: TBA.
\end{itemize}

\subsection{Header \tcode{<graph_view>} synopsis [graph.syn]}

\begin{lstlisting}
namespace std::graph::views {

// ...

template <typename G>
auto vertexlist(G&& g);

template <typename G>
auto incidence(G&& g, vertex_reference_t<G>);

template <typename G>
auto neighbors(G&& g, vertex_reference_t<G>);

template <typename G>
auto edgelist(G&& g);

// ...
// vertices_depth_first_search
// edges_depth_first_search
// sourced_edges_depth_first_search
// vertices_breadth_first_search
// edges_breadth_first_search
}
\end{lstlisting}

\subsection{Header \tcode{<graph_algorithm>} synopsis [graph.syn]}

\begin{lstlisting}
namespace std::graph {

// ...tag_invoke


// ...
}
\end{lstlisting}

\subsection{Header \tcode{<csr_graph>} synopsis [graph.syn]}

\begin{lstlisting}
namespace std::graph {

// ...

template<class EV, class VV, class GV, class VId, class Alloc>
class csr_graph;

// ...
}
\end{lstlisting}


\section{Acknowledgements}
Michael Wong's work is made possible by Codeplay Software Ltd., ISOCPP Foundation, Khronos and the Standards Council of Canada.  The authors wish to further thank the members of SG19 for their contributions.

\footnotesize
\bibliographystyle{unsrt}
\bibliography{P1709R3}
\normalsize

\end{document}
