\documentclass[10pt,onecolumn]{article}

\usepackage[
	left=0.9in,
	top=1.0in,
	right=0.9in,
	bottom=1.0in]{geometry}
\usepackage{soul}
\usepackage{times}
\usepackage[scaled=.90]{helvet} % Use helvetica for sf and scale to proper size

%% \usepackage{url}  %% use hyperref instead

%% Define colors
\usepackage[hyperref]{xcolor}

\definecolor{light-gray}{gray}{0.95}
\definecolor{medium-gray}{gray}{0.33}

\definecolor{bs_keyword}{HTML}{990055} % {D33682} 
\definecolor{bs_name_function}{HTML}{0077AA} % {268BD2}
\definecolor{bs_comment_single}{HTML}{708090} % {2AA198}
\definecolor{bs_name}{HTML}{0077AA} % {2AA198}
\definecolor{bs_number}{HTML}{000000}
\definecolor{bs_string}{HTML}{A67F59}
\definecolor{bs_highlight_background}{HTML}{F2F2F2}
\definecolor{bs_h1_h2_h3}{HTML}{005A9C}
\definecolor{bs_a_href}{HTML}{034575}
\definecolor{comment}{HTML}{0000A0}

%% Customize section headings
\usepackage{titlesec}
\titleformat*{\section}{\normalfont\Large\bfseries\color{bs_h1_h2_h3}}
\titleformat*{\subsection}{\normalfont\large\bfseries\color{bs_h1_h2_h3}}
\titleformat*{\subsubsection}{\normalfont\normalsize\bfseries\color{bs_h1_h2_h3}}

%% Customize hyperlinks
\usepackage{hyperref}
\hypersetup{
  colorlinks = true,
  linkcolor = bs_h1_h2_h3% {0 .35 .61} % 005A9C
}

%% Customize code formatting
\usepackage{listings}
\lstset
{
  language=[11]C++,
  backgroundcolor=\color{bs_highlight_background},
  basicstyle=\ttfamily, % \bf\ttfamily,
  breaklines=true,
  commentstyle=\color{bs_comment_single},
  keywordstyle=\color{bs_keyword},
  identifierstyle=\color{bs_name_function},
  stringstyle=\color{bs_string},
  frame=single,
  framerule=0pt,
  showstringspaces=false
}

%% Keywords for C++20
\lstset{
  morekeywords = {
    char8_t,
    concept,
    co_await,
    co_return,
    co_yield,
    requires,
    import,
    module
  }
}

%% \lstset{
%%   emph = { % [20]
%%     import,
%%     module
%%   }
%% }

%% Shortcut for inline code
\newcommand{\tcode}[1]{\lstinline[breaklines=true]{#1}}

\newcommand{\comment}[2]{{\color{comment}[{\sc #1:} \textsf{#2}]}}
\newcommand{\phil}[1]{\comment{Phil}{#1}}
\newcommand{\andrew}[1]{\comment{Andrew}{#1}}



\begin{document}

\begin{titlepage}
~
\vfill
\begin{center}
\LARGE
\textbf{P1709R3 Graph Library}\\
\vspace{12pt}
\normalsize
	Phillip Ratzloff (SAS Institute)\\
	Andrew Lumsdaine (TileDB/University of Washington)\\
	Richard Dosselmann (University of Regina)\\
	Michael Wong (Codeplay)\\
	Matthew Galati (SAS Institute)\\	
	Jens Maurer\\
	Domagoj Saric\\
	Jesun Firoz\\
	Kevin Deweese\\
\end{center}
\vspace{32pt}
\begin{tabular}{ll}
\textbf{Document Number:} & P1709R3\\
\textbf{Date:} & \hl{May 12}, 2022 (mailing)\\ 
\textbf{Project:} & ISO JTC1/SC22/WG21: Programming Language C++\\
\textbf{Audience:} & SG19, WG21, LEWG\\
\textbf{Emails:}
	&\texttt{Phil.Ratzloff@sas.com}\\
	&\texttt{Andrew.Lumsdaine@tiledb.com}\\
	&\texttt{dosselmr@cs.uregina.ca}\\
	&\texttt{michael@codeplay.com}\\
	&\texttt{Matthew.Galati@sas.com}\\
\textbf{Reply to:}
	&\texttt{\textbf{Phil.Ratzloff@sas.com}}\\
\end{tabular}
\vfill
~
\end{titlepage}

\tableofcontents

\clearpage

\section{Introduction}
This document proposes the addition of a \textbf{graph data structure} and \textbf{graph algorithms} to the C++ library to support \textbf{machine learning} (ML), as well as other applications. ML is a large and growing field, both in the \textbf{research community} and \textbf{industry}, that has received a great deal of attention in recent years. This paper presents an \textbf{interface} of the proposed algorithms, views, graph functions and data structures.

\subsection{Motivation}
A graph data structure, used in ML and other \textbf{scientific} domains, as well as \textbf{industrial} and \textbf{general} programming, does \textbf{not} presently exist in the C++ standard. In ML, a graph forms the underlying structure of an \textbf{artificial neural network} (ANN). In a \textbf{game}, a graph can be used to
represent the \textbf{map} of a game world. In \textbf{business} environments, graphs arise as \textbf{entity relationship diagrams} (ERD) or \textbf{data flow diagrams} (DFD). In the realm of \textbf{social media}, a graph represents a \textbf{social network}.

\subsection{Priorities}
\begin{itemize}
\item Have algorithm syntax that is simple, expressive and easy to understand.
\item Define views for common traversal of a graph including vertexlist, incidence, neighbors, edgelist, depth-first search and breadth-first search.
\item Support high-performance algorithms and data structures.
\begin{itemize}
\item Algorithms in this proposal require vertices to be in random access containers with an integral vertex\_id.
\end{itemize}
\item But, don't prevent the ability to extend the design externally or in future proposals. Examples include
\begin{itemize}
\item Allow for incoming edges on a vertex.
\item Allow for vertices in non-random-access containers like map and unordered\_map, and with non-integral keys, with the understanding that 
doing so will result in performance that will be less than ideal. While such functionality is not expected to be included in any proposal in a future 
standard, graphs in the wide world can use such data structures and the design should accomodate them. Toward this goal, graph concepts only
require vertices to be a forward\_range and algorithms need to define their requirements as random\_access\_range and integral<vertex\_key<G>>.
\end{itemize}
\item Support optional user-defined value types on an edge, vertex and/or the graph itself.
\item Make it easy to adapt existing graph data structures to the library.
\item Define useful type aliases to tag graphs that algorithms can take advantage of, such as undirected\_edge and adjacency\_matrix.
\item Provide an initial suite of useful functionality that includes algorithms, views and at least one graph data structure.
\end{itemize}

\subsection{Examples: Example 1}
\subsection{Examples: Example 2}

\subsection{What this proposal is  \textbf{not}}
This paper limits itself to incidence graphs only. It does not include hypergraphs.

\hl{TBD: Bipartite graphs?}


\subsection{Prior Art}
boost::graph \\
\hl{Other?}

\subsubsection{Inspirations}
NWGraph

\subsection{Revision History}
\subsubsection*{P1709R3}
Simplifiy the Graph API by focusing on functionality needed for an incidence graph, removing mutable functions and removing unnecessary functions. Replaced the \tcode{vertex_vertex_range} and \tcode{edge_range} with \tcode{neighbors} and \tcode{edgelist} Graph Views and added new \tcode{vertexlist} and \tcode{incidence} views. Simplified concepts and graph traits.

\subsubsection*{P1709R2}
Define the \textbf{uniform API} for undirected and directed algorithms (an extended API also exists for directed graphs). Added \textbf{concepts} for undirected, directed and bidirected graphs. Refined \textbf{DFS} and \textbf{BFS} range definitions from prototype experience. Refined \textbf{shortest paths} and \textbf{transitive closure} algorithms from input and prototype experience.

\subsubsection*{P1709R1}
Rewrite with a focus on a \textbf{purely functional design}, emphasizing the algorithms and graph API. Also added \textbf{concepts} and \textbf{ranges} into the design. Addressed concerns from Cologne review to change to functional design.

\subsubsection*{P1709R0}
Focus on \textbf{object-oriented API} for data structures and example code for a few algorithms.

\section{Design - Introduction}
\section{Design - user side}
\subsection{Algorithms}
\subsection{Shortest Paths}
\paragraph{Dijkstra's Algorithm}
Dijkstra's algorithm \cite{REF_} ...

\paragraph{Bellman-Ford Algorithm}
The Bellman-Ford algorithm \cite{REF_} ...

\subsubsection{Components}
\paragraph{Connected Components}
Connected components \cite{REF_} ...

\paragraph{Strongly Connected Components}
Strongly connected components \cite{REF_} ...

\paragraph{Biconnected Components}
Biconnected components \cite{REF_} ...

\paragraph{Articulation Points}
Articulation points \cite{REF_} ...

\subsubsection{Transitive Closure}
Transitive closure \cite{REF_} ...
\paragraph{dfs\_transitive\_closure}
\paragraph{warshall\_transitive\_closure}

\subsection{Views}
\subsubsection{vertexlist view}
\subsubsection{incidence view}
\subsubsection{neighbor view}
\subsubsection{edgelist view}
\subsubsection{depth\_first\_search views}
\subsubsection{breadth\_first\_search views}
\subsection{Concepts and traits}
\subsection{Functions}
\section{Design - graph data structure side}
\subsection{Function Specialization}
\section{Specification}
\section{Library introduction [library]}
\section{Graph introduction [graph]}
\section{algorithms [graph.algorithms]}
\section{views [graph.views]}
\section{customization points [graph.functions]}


\section{Old Introduction (Content after this will be moved above or removed)}
\section{Impact on the Standard}
This proposal is a pure \textbf{library} extension.

\subsection{Graph}
 A \textit{graph} \cite{REF_graph} $G = (V, E)$ is a set of \textit{vertices} \cite{REF_graph} $V$, \textbf{points} in a space, and \textit{edges} \cite{REF_graph} $E$, \textbf{links} between these vertices. Edges may or may not be \textbf{oriented}, that is, \textit{directed} \cite{REF_graph} or \textit{undirected} \cite{REF_graph}, respectively. Moreover, edges may be \textit{weighted} \cite{REF_graph}, that is, assigned a value. Both \textbf{static} and \textbf{dynamic} implementations of a graph exist, specifically a (static) \textbf{matrix}, each having the typical advantages and disadvantages associated with static and dynamic data structures.

\subsection{Algorithms}
TBA

%\subsubsection{Other Algorithms}
%The following algorithms have been identified for consideration in (an) \textbf{additional} paper(s).
%
%\begin{enumerate}
%\item Minimum spanning tree
%\item Maximum flow
%\item Matching
%\item Bipartite matching
%\item Min-cost network flow
%\item Isomorphism
%\item Subgraph isomorphism
%\item Centrality
%\item Minimum cut
%\item Cycle detection
%\item Path enumeration
%\item Community detection
%\item Clique enumeration
%\item Find triangles
%\item Lowest common ancestor
%\item Dominator algorithms
%\end{enumerate}

\subsection{Views}
TBA

\subsection{Graph Types, Traits, Concepts and Functions}
TBA

\subsection{\tcode{csr_graph} Data Structure}
TBA

\section{Design Decisions}
\subsection{Graph Library Organization}
A physical graph is made up of a range of vertices, where each vertex has a range of edges. This is known as an Incidence Graph. There are a variety of 
ways it can be implemented and such a description is outside the scope of this paper. All implementations share a common interface represented by the
Graph API in this paper.

The Graph API is a set of types, traits and concepts that describe a graph, and a set of functions that provide low-level access to the 
underlying graph with the following characteristics:
\begin{enumerate}
\item All functions are Customization Point Objects (CPO) that can be overridden to integrate a graph with this library. 
6-9 functions must be overridden for a graph data structure to fully integrate with this library, and more functions are available if needed. This proposal includes 
\tcode{csr_graph}, a static graph for performance, that demonstrates how CPOs are overridden.
\item The graph types are defined by the return types of the graph functions, or derivative of them.
\item User-defined value types can be defined for the edge, vertex and graph types. A type of \tcode{void} is assumed if no type has been defined.
Unlike existing containers in the standard, the type is optional. Not all algorithms require values on an edge or vertex, simply using the relationships
between vertices as defined by edges.
\end{enumerate}

Graph Views are built on top of the Graph API and provide common ways for algorithms to iterate through the objects of a graph:
\begin{enumerate}
\item \tcode{views::vertexlist(g)} returns a range of \tcode{views::vertex_view}, for the vertices in the graph. 
\item \tcode{views::incidence(g,u)} returns a range of \tcode{views::edge_view}, for the edges of a source vertex.
\item \tcode{views::neighbors(g,u)} returns a range of \tcode{views::neighbor_view}, for the neighboring vertices of a source vertex.
\item \tcode{views::edgelist(g)} returns a range of \tcode{views::edge_view}, for all the edges of a graph. 
\end{enumerate}

Graph Algorithms use Graph Views (and the Graph API as needed) to traverse the graph to acheive its goal. If an algorithm needs a value from 
a vertex or edge, it should accept a function object that retreives the value. It should never call \tcode{vertex_value(g,u)} or \tcode{edge_value(g,uv)}
directly.

Like the Standard Telmplate Library (STL), algorithms and data structures can be implemented independently and be used interchangeably,
as long as the data structure meets the concept constraints defined by an algorithm.

A graph can be tagged with type aliases to describe underlying characteristics that can be used by an algorithm. Two examples
in this proposal include \tcode{is_undirected_edge_v<E>} and \tcode{is_adjacency_matrix_v<G>}.

\subsection{Separation of Graph Algorithm and Data Structure Requirements}

There are a wide variety of ways to represent a graph that can include both outgoing and incoming edges, undirected edges,
sparse vertex ids, non-numeric vertex ids, etc. However, it is necessary to constrain the design to focus on providing reasonable 
value for the widely accepted algorithms currently available for graphs. With that in mind, the following guidelines have been established.
\begin{enumerate}
\item Graph data structures are assumed to have vertices in a sized \tcode{forward_range}, and edges in an unsized \tcode{forward_range}.
\item Algorithms in this proposal will target a subset of graphs with vertices in a sized \tcode{random_acccess_range} with 
integral ids, and edges will be in a \tcode{forward_range}, for simplicity and performance. Algorithms may require edges to be sized as
needed. It is anticipated that future algorithm proposals will continue to follow these requirements.
\item Views follow the same requirements as the algorithms.
\end{enumerate}

The discrepancy between these definitions is to enable a wider variety of algorithms and graph data structures outside the standard that 
can leverage the underlying design. For instance, the following should be possible in graphs and algorithms outside of this proposal:

\begin{enumerate}
\item Incoming edges could exist for vertices, in addition to the existing incidence, or outgoing, edges for a bi-directed graph.
\item Vertices could be stored in a \tcode{map}, \tcode{unordered_map} or similar data structure for sparse, non-contiguous ids.
\andrew{I (strongly) think this should not be allowed.  If the outer range of a graph is required to be a random-access range, it won't be.  The reason I don't think it should be allowed is that having non-constant time lookup of vertices in the outer range will change the computational complexity of the algorithms---something users will not expect.}
\phil{I support that all algorithms in the standard will require a random access range, but the requirement for it belongs on the algorithm, not the outer range itself. Allowing the outer range to be bidirectional will allow the use of data structures and algoritthms to be used
outside the standard that don't offer the same performance guarantees (e.g. O(log n) access). Accepting that the performance of such a situation is less than optimal, it is better than having nothing at all if we prevent it from happening.}
\item Non-integral ids could be used, such as strings or compound types, that follow the comparison requirements of the vertex container.  \andrew{Similarly here---if this results in non-constant time lookup it is changing the algorithmic complexity.} 
\phil{I expect algorithms in the standard to always use integral id's and is part of the algorithms, not the data structures.  This is a similar argument as before, where we should support a broader set of functionality outside of the standard.}
\item Edges could be stored in a map or set, ordered on the neighbor id, for faster neighbor lookup.
  \andrew{Similarly here.  Traversal of a neighbor list must be linear time in number of neighbors for correct algorithmic complexity.}
  \phil{Use of map or set will not impact linear time for traversing edges in this case. Again, this is to support broader functionality outside of the standard.}
\end{enumerate}

Such features can be important for embedded graph implementations in domain-specific cases and this proposal should not prevent them. 
Future papers could consider proposing these features.
\andrew{We could consider allowing these kinds of things, with suitable warnings in the documentation about computational complexity.  This is similar to doing \tcode{binary_search} on a forward range---I guess the standard allows it, but in the fine print the standard notes that \tcode{binary_search} is then a linear search rather than a binary search.}
\phil{I don't expect us to use it. I suppose we could make a statement that anything that goes outside of the O(1) for vertices would have an impact, but it's outside of our design.} 
\phil{What I'm stating isn't anything different than I've said already. Maybe it needs to be restated to assure the reader?}

\subsection{Customization Point Objects}
All functions for the Graph API, Views and Algorithms are defined as Customization Point Objects (CPO), allowing them to be overriden for
specific graphs. \tcode{tag_invoke} is used to implement the CPO functions.

\subsection{Namespaces and Headers}
Graph algorithms, views and data structures are unique and not easily interchanged with other elements of the standard library. For
instance, graph algorithms wouldn't be used on a non-graph range. For this reason it is recommended to have them in their own 
namespaces. Suggestions for namespaces are \tcode{std::graph} and
\tcode{std::ranges::graph} for the root namespace. The graph namespaces proposed include
\begin{itemize}
\item[]\tcode{graph}
\item[]\tcode{graph::access}
\item[]\tcode{graph::views}
\item[]\tcode{graph::views::access}
\end{itemize}

Proposed headers include
\begin{itemize}
\item[]\tcode{<graph>}
\item[]\tcode{<graph_view>}
\item[]\tcode{<graph_algorithm>}
\item[]\tcode{<csr_graph>}
\end{itemize}

\section{Technical Specifications}
TBA

\subsection{Header \tcode{<graph>} synopsis [graph.syn]}

\begin{lstlisting}
namespace std::graph {

// ...

template <typename G>
auto vertices (G& g);

template <typename G>
auto vertex_id(G& g, vertex_iterator_t<G>);

template <typename G>
auto vertex_value(G& g, vertex_reference_t<G>);

// ...
}
\end{lstlisting}

\vspace{10pt}

\noindent The following is a synopsis of the functions and classes above.

\begin{lstlisting}
template <typename G>
auto vertices (G& g);
\end{lstlisting}
%
\begin{itemize}
\item Preconditions: TBA.
\item Effects: TBA.
\item Complexity: TBA.
\item Returns: TBA.
\item Remarks: TBA.
\end{itemize}

\vspace{10pt}

\begin{lstlisting}
template <typename G>
auto vertex_id (G& g, vertex_iterator_t<G>);
\end{lstlisting}
%
\begin{itemize}
\item Preconditions: TBA.
\item Effects: TBA.
\item Complexity: TBA.
\item Returns: TBA.
\item Remarks: TBA.
\end{itemize}

\vspace{10pt}

\begin{lstlisting}
template <typename G>
auto vertex_value (G& g, vertex_reference_t<G>);
\end{lstlisting}
%
\begin{itemize}
\item Preconditions: TBA.
\item Effects: TBA.
\item Complexity: TBA.
\item Returns: TBA.
\item Remarks: TBA.
\end{itemize}

\subsection{Header \tcode{<graph_view>} synopsis [graph.syn]}

\begin{lstlisting}
namespace std::graph::views {

// ...

template <typename G>
auto vertexlist(G& g);

template <typename G>
auto incidence(G& g, vertex_reference_t<G>);

template <typename G>
auto neighbors(G& g, vertex_reference_t<G>);

template <typename G>
auto edgelist(G& g);


// ...
}
\end{lstlisting}

\subsection{Header \tcode{<graph_algorithm>} synopsis [graph.syn]}

\begin{lstlisting}
namespace std::graph {

// ...

template <typename G>
auto breath_first_search(G& g, vertex_reference_t<G> seed);

template <typename G>
auto depth_first_search(G& g, vertex_reference_t<G> seed);


// ...
}
\end{lstlisting}

\subsection{Header \tcode{<csr_graph>} synopsis [graph.syn]}

\begin{lstlisting}
namespace std::graph {

// ...

template<class EV, class VV, class GV, class VId, class Alloc>
class csr_graph;

// ...
}
\end{lstlisting}


\section{Acknowledgements}
Michael Wong's work is made possible by Codeplay Software Ltd., ISOCPP Foundation, Khronos and the Standards Council of Canada.  The authors wish to further thank the members of SG19 for their contributions.

\footnotesize
\bibliographystyle{unsrt}
\bibliography{P1709R3}
\normalsize

\end{document}
