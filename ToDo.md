# ToDo & Issues

## Open

### ToDo 
- API
  - [ ] Common
  - [x] Ranges
  - [ ] Concepts and type_traits
    - [x] graph: incidence_graph, sourced_incidence_graph, adjacency_matrix, undirected_incidence_graph
    - [ ] views: vertex_view, edge_view, neighbor_view
    - [ ] functions: VVF, EVF
  - [x] Accessor functions
  - [ ] Views
    - [ ] incidence
      - [ ] unit tests for Sourced edges (sourced and unsourced graph)
      - [ ] unit tests for undirected_graph<G>
    - [ ] neighbors
      - [ ] unit tests for Sourced edges (sourced and unsourced graph)
      - [ ] unit tests for undirected_graph<G>
    - [ ] edgelist
      - [ ] unit tests for undirected_graph<G>
- Algorithms
  - [ ] Common
  - [ ] Ranges
    - [ ] bfs_vertex_range
    - [ ] bfs_edge_range
    - [ ] dfs_vertex_range
    - [ ] dfs_edge_range
  - [ ] Algorithms (full & simplified/book)
    - [ ] Shortest Paths
      - [x] Dijkstra book (impl from AndrewL)
      - [ ] dijkstra_shortest_paths
      - [ ] bellman_ford_shortest paths
    - [ ] Components
      - [ ] connected_components
      - [ ] strongly_connected_components
      - [ ] biconnected_components
      - [ ] articulation_points
    - [ ] Transitive Closure
      - [ ] dfs_transitive_closure
      - [x] warshall_transitive_closure
      - [ ] warshall_transitive_closure (parallel)
    - [ ] Edgelist algorithms (prove design; not for P1709)
      - [ ] Maximal Independent Set (edgelist) (from NWGraph --> Matt)
      - [ ] Union Find (edgelist)
    - [ ] copy (g1 --> g2) (not for P1709)
- Containers (data structures)
    - [x] csr_graph (for P1709)
      - [ ] Use concepts for load, load_edges, load_vertices, ctors
      - [x] Support VV=void
      - [x] Use copyable_vertex & copyable_edge concepts in graph ctors, load functions
    - [ ] dynamic_graph
      - [ ] Use concepts for load, load_edges, load_vertices, ctors
      - [ ] test push_or_insert() to assure it does the right thing for const, value, &, &&, ...
      - [ ] graph with map-based vertices (requires different algorithm impl)
      - [x] Use copyable_vertex & copyable_edge concepts in graph ctors, load functions
    - [ ] constexpr graph based on std::array
    - [ ] bipartite_graph<V1,V2,V3>
    - [ ] undirected_adjacency_list
    - [ ] directed_adjacency_vector
- [ ] Testing Patterns
  - [x] Validate content
  - [ ] Validate graph API
    - [x] All functions work (with/without defaults) on existing data structures
    - [ ] Default values same as dynamic graph values
    - [ ] void & non-void for EV, VV & GV can store & retrieve values
    - [ ] Validate const
    - [ ] Validate copy and move to set EV, VV & GV values
  - [ ] Validate algorithms
  - [ ] Apply to multiple data structures
    - [ ] load_edges() can use copy and move to set EV & VV values
    - [ ] use load_ordered_graph() for all data structures (consistency)
    - [ ] use values, references and ptrs for value types: EV, VV, GV
    - [ ] support const on value types(?)
- Tools, Libraries & Infrastructure
  - [ ] Create mtx parser (from nwgraph)
  - [ ] Constexpr unit tests (initial tests to verify pattern)
  - [ ] Generate doxygen output
  - [ ] Validate address sanitizer build
  - [ ] Support Clang (waiting for full concepts support)
  - [ ] Performance tests
- github - graph-v2
  - [ ] Add processes to build & run unit tests on checkin
  - [ ] Make graph-v2 public. Requirements
    - [ ] 2+ algorithms implemented
    - [ ] README.md with Description + Getting Started
- Feature & performance comparison
  - [ ] boost::graph
  - [ ] NWGraph
  - [ ] Lemon
- C\+\+20 and C\+\+23
  - [ ] modules
  - [ ] coroutines (simplify DFS, BFS & TopoSort?)
- Documentation
  - [x] Decprecate original "graph" repository
  - [ ] README.md
    - [ ] Add general description
    - [x] Add Getting Started
  - [ ] P1709
    - [x] Google Doc --> LaTex
    - [ ] Add overview/goal
    - [ ] Add sections
- Feedback
- Code Review
  - [ ] graph concepts
  - [ ] undirected_graph<G> concept + source/target swapping in views
  - [ ] views iterator design: 
    - [ ] use of subrange
    - [ ] storing values in iterator: shadow struct, setting values in operator*(), mutable value, ref_to_ptr
    - [ ] fnc obj as ptr vs. value?
    - [ ] vs. NWGraph (returning references vs. values)
  - [ ] tag_invoke design & use (namespaces, tag names, etc.)
- Readiness
  - [ ] Sep-2022 CppCon
  - [ ] Oct-2022 WG21 Kona
  - [ ] Feb-2025 deadline for C++26

### Issues
- [ ] Can't run tests in VS+WSL2 (they will run in VSCode, but is slow)
  - [ ] Submit a defect to MS?
- [ ] csv_parser
  - [ ] CSVReader doesn't conform to the C++20 input_range or forward_range concepts; can't define load functions properly
    - [ ] What's missing? const types; other?
  - [ ] leading & trailing spaces for quoted values aren't ignored
  - [ ] can it be reused for multi-pass?
  - [x] Fork: No response to issues submitted
- [ ] Are the CSR vertex & edge types different? (requirement of incidence and adjacency concepts)
- [ ] If we have an access namespace, do we need a container namespace?
- [ ] SG19 Input
  - [ ] Core data structures? static graph(CSR), dynamic graph (vol variant)
  - [ ] vertex_id or vertex_id?
- [ ] Should operator\[\](n) -> vertex& be a requirement for a graph?
- [ ] Can std::array be used as a basis for a constexpr graph? What would the graph be?
- [ ] Does a LaTeX document take fewer pages than equivilent in Google Docs?
- [ ] SG19 Questions
- [ ] Can CSR edges have a void value? (e.g. no v vector)
- [ ] How easy is it to write a view w/o the graph API?
- [ ] How to validate constexpr? (need to use std::array)
- [ ] CSR showed that there can be issues when an "edge" type is just an int, which is the same as the VId. How to adapt existing graphs?
- [ ] Can transform_view be used in place of the projections in the graph views?
- [ ] How to support bipartite graphs using different vertex types?
  - [ ] Requires definition of 2+ types of vertices. How to define vertex type: compile-time vs. run-time?
    - [ ] vertices are stored as a range of range of vertices, where the outer range is the type of vertex
  - [ ] Need proof-of-concept graph data structure to demonstrate
  - [ ] Option 1: extend API & Views with the type (or hidden if not used)
    - [ ] keeps uniformity of vertex type
    - [ ] may require use of variant for vertex_value type (having a unique value__type per vertex type significantly increases API complexity)
    - [ ] API extensions
      - [ ] vertices(g,type)
      - [ ] find_vertex(g,type,id)
      - [ ] vertex_type(g,u), or vertex_type(g,ui) (like vertex_id)
      - [ ] target_type(g,uv), source_type(g,uv), other_type(g,uv)
    - [ ] View exensions
      - [ ] vertex_view would need to include vertex type
      - [ ] edge_view would need to include target & source vertex type (with the id)
      - [ ] neighbor_view would need to include target vertex type
      - [ ] These extensions could be a template parameter based on the underlying type of graph; they would be absent if not needed
      - [ ] How to efficiently iterate through vertices of a specific type?
  - [ ] Option 2: use existing vertex_id to be a pair<vtx_type,vtx_id>
    - [ ] Can the existing design adapt to this? (Best option if it can be made to work)
    - [ ] keeps uniformity of vertex type
    - [ ] may require use of variant for vertex_value type
    - [ ] How well would it adapt to existing bipartite graphs?
  - [ ] Option 3: use C++ types to distinguish vertex types
    - [ ] invasive to the existing design and would make it significantly more complicated
    - [ ] would delay existing design by months and there's no guarantee to be successful
- [ ] Should we worry about row-major & column-major ordering of adjacency_matrix? always assume row-major?
- [ ] Do we need a run-time function to check for undirectedness, in addition to is_undirected_edge_v<EV>? Is it a run-time property for some graphs?
- [ ] Is there a way for EVF to take both edge_value and fnc obj? (same for VVF & vertex_value)
- [ ] The default for edges(g,uid) CPO isn't being found by msvc or gcc

## Resolved
### ToDo Completed
- API
  - [x] graph types
  - [x] vertex types
  - [x] edge types
  - [x] ranges
    - [x] vertex_range
    - [x] vertex_edge_range
  - [x] add overridable is_undirected_edge_v<E> & undirected_incidence_graph<G> concept
  - [x] add overridable is_adjacencey_matrix_v<G>
  - [x] "key" --> "id"
- Views
  - [x] vertexlist
  - [x] edgelist
  - [x] incidence
  - [x] sourced_incidence
  - [x] neighbors
  - [x] sourced_neighbors
- Algorithms
- Containers (data structures)
    - [x] dynamic_graph (adjustable to different vertex & edge containers)
      - [x] Implement graph, vector, edge
      - [x] Load from CSV file
      - [x] Add \<bool sourced\> template parameter to include source_id
      - [x] use copyable_vector_t & copyable_edge_t for loaders, ctors and initializer 
    - [x] csr_graph
      - [x] Implement graph, vertex, edge
      - [x] Load from CSV file
      - [x] Validate with vofl_graph tests
      - [x] use copyable_vector_t & copyable_edge_t for loaders, ctors and initializer lists
- C\+\+20 and C\+\+23
  - [x] connection points (e.g. tag_invoke)
- Tools, Libraries & Infrastructure
  - [x] Use CMake Presets; must work with both VS & VSCode
  - [x] Use conan for libraries when possible: catch2, fmt, spdlog, range-v3
  - [x] Include csv_parser library
  - [x] Create graph-v2 repository in github
- Documentation
- Feedback

### Issues Resolved
- [x] vertex_id(g,u) now takes a vertex reference (not iterator)
  - [x] how to define vertex_id_t without calling vertex_id()? 
  - [x] make it obvious it's unavailable for non-contiguous vertices
  - [x] Answer: for([uid,u] : vertices(g))
- [x] Best way to extend vol_graph to support different container types?
  - [x] Answer: graph_traits with template specializations for user-defined values. vol_graph renamed to dynamic_graph
- [x] What is the best dynamic graph to propose for the std? vol, vov? premature. Revisit later
- [x] Can an edgelist be trivially created by a user? (e.g. vector<pair<target_id,weight>>) yes; need to flush this out in paper
- [x] Can we drop the vertex_vertex_range in favor of just having vertexlist(g,u) [adjacency view]? yes
- [x] Can std::vector be used as a basis for a constexpr graph? No because we can't have variables of vector
- [x] Should CSR support source_id on edges (Sourced template parameter)? No. Views will be able to provide it so it won't be needed.
- [x] edge_list_graph (edgelist_edge<VId,E,EV> view?): edgelist is a view, or projection of a container
- [x] Are there any issues with using tag_invoke? It appears not. Others are using it in papers.
- [x] key vs. id? "key" is a better term, but id has been used extensively in boost and other graph libraries and will be easier for people to recognize
